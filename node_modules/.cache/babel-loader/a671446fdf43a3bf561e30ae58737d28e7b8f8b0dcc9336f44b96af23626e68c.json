{"ast":null,"code":"import _get from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"/Users/cadany/WebstormProjects/monaco/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { onUnexpectedError } from './errors.js';\nimport { once as onceFn } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, SafeDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nvar _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nvar _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n  Event.None = function () {\n    return Disposable.None;\n  };\n  function _addLeakageTraceLogic(options) {\n    if (_enableSnapshotPotentialLeakWarning) {\n      var origListenerDidAdd = options.onDidAddListener;\n      var stack = Stacktrace.create();\n      var count = 0;\n      options.onDidAddListener = function () {\n        if (++count === 2) {\n          console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n          stack.print();\n        }\n        origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n      };\n    }\n  }\n  /**\n   * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n   * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n   * result of merging events and to try prevent race conditions that could arise when using related deferred and\n   * non-deferred events.\n   *\n   * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n   * (eg. latency of keypress to text rendered).\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function defer(event, disposable) {\n    return _debounce(event, function () {\n      return void 0;\n    }, 0, undefined, true, undefined, disposable);\n  }\n  Event.defer = defer;\n  /**\n   * Given an event, returns another event which only fires once.\n   *\n   * @param event The event source for the new event.\n   */\n  function _once(event) {\n    return function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      // we need this, in case the event fires during the listener call\n      var didFire = false;\n      var result = undefined;\n      result = event(function (e) {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = _once;\n  /**\n   * Maps an event of one type into an event of another type using a mapping function, similar to how\n   * `Array.prototype.map` works.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param map The mapping function.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function _map(event, map, disposable) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (i) {\n        return listener.call(thisArgs, map(i));\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.map = _map;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function _forEach(event, each, disposable) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (i) {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.forEach = _forEach;\n  function _filter(event, filter, disposable) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (e) {\n        return filter(e) && listener.call(thisArgs, e);\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.filter = _filter;\n  /**\n   * Given an event, returns the same event but typed as `Event<void>`.\n   */\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  function any() {\n    for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n      events[_key] = arguments[_key];\n    }\n    return function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return combinedDisposable.apply(void 0, _toConsumableArray(events.map(function (event) {\n        return event(function (e) {\n          return listener.call(thisArgs, e);\n        }, null, disposables);\n      })));\n    };\n  }\n  Event.any = any;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function _reduce(event, merge, initial, disposable) {\n    var output = initial;\n    return _map(event, function (e) {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event.reduce = _reduce;\n  function snapshot(event, disposable) {\n    var listener;\n    var options = {\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        listener = event(emitter.fire, emitter);\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        listener === null || listener === void 0 ? void 0 : listener.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    var emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  function _debounce(event, merge) {\n    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var flushOnListenerRemove = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var leakWarningThreshold = arguments.length > 5 ? arguments[5] : undefined;\n    var disposable = arguments.length > 6 ? arguments[6] : undefined;\n    var subscription;\n    var output = undefined;\n    var handle = undefined;\n    var numDebouncedCalls = 0;\n    var doFire;\n    var options = {\n      leakWarningThreshold: leakWarningThreshold,\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        subscription = event(function (cur) {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          doFire = function doFire() {\n            var _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          };\n          if (typeof delay === 'number') {\n            clearTimeout(handle);\n            handle = setTimeout(doFire, delay);\n          } else {\n            if (handle === undefined) {\n              handle = 0;\n              queueMicrotask(doFire);\n            }\n          }\n        });\n      },\n      onWillRemoveListener: function onWillRemoveListener() {\n        if (flushOnListenerRemove && numDebouncedCalls > 0) {\n          doFire === null || doFire === void 0 ? void 0 : doFire();\n        }\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        doFire = undefined;\n        subscription.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    var emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  Event.debounce = _debounce;\n  /**\n   * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function accumulate(event) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var disposable = arguments.length > 2 ? arguments[2] : undefined;\n    return Event.debounce(event, function (last, e) {\n      if (!last) {\n        return [e];\n      }\n      last.push(e);\n      return last;\n    }, delay, undefined, true, undefined, disposable);\n  }\n  Event.accumulate = accumulate;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function _latch(event) {\n    var equals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (a, b) {\n      return a === b;\n    };\n    var disposable = arguments.length > 2 ? arguments[2] : undefined;\n    var firstCall = true;\n    var cache;\n    return _filter(event, function (value) {\n      var shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event.latch = _latch;\n  /**\n   * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @example\n   * ```\n   * const event = new EventEmitter<number | undefined>().event;\n   * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n   * ```\n   *\n   * @param event The event source for the new event.\n   * @param isT A function that determines what event is of the first type.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function split(event, isT, disposable) {\n    return [Event.filter(event, isT, disposable), Event.filter(event, function (e) {\n      return !isT(e);\n    }, disposable)];\n  }\n  Event.split = split;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function buffer(event) {\n    var flushAfterTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var buffer = _buffer.slice();\n    var listener = event(function (e) {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    var flush = function flush() {\n      buffer === null || buffer === void 0 ? void 0 : buffer.forEach(function (e) {\n        return emitter.fire(e);\n      });\n      buffer = null;\n    };\n    var emitter = new Emitter({\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        if (!listener) {\n          listener = event(function (e) {\n            return emitter.fire(e);\n          });\n        }\n      },\n      onDidAddFirstListener: function onDidAddFirstListener() {\n        if (buffer) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  var ChainableEvent = /*#__PURE__*/function () {\n    function ChainableEvent(event) {\n      _classCallCheck(this, ChainableEvent);\n      this.event = event;\n      this.disposables = new DisposableStore();\n    }\n    _createClass(ChainableEvent, [{\n      key: \"map\",\n      value: function map(fn) {\n        return new ChainableEvent(_map(this.event, fn, this.disposables));\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(fn) {\n        return new ChainableEvent(_forEach(this.event, fn, this.disposables));\n      }\n    }, {\n      key: \"filter\",\n      value: function filter(fn) {\n        return new ChainableEvent(_filter(this.event, fn, this.disposables));\n      }\n    }, {\n      key: \"reduce\",\n      value: function reduce(merge, initial) {\n        return new ChainableEvent(_reduce(this.event, merge, initial, this.disposables));\n      }\n    }, {\n      key: \"latch\",\n      value: function latch() {\n        return new ChainableEvent(_latch(this.event, undefined, this.disposables));\n      }\n    }, {\n      key: \"debounce\",\n      value: function debounce(merge) {\n        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n        var leading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var flushOnListenerRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        var leakWarningThreshold = arguments.length > 4 ? arguments[4] : undefined;\n        return new ChainableEvent(_debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));\n      }\n    }, {\n      key: \"on\",\n      value: function on(listener, thisArgs, disposables) {\n        return this.event(listener, thisArgs, disposables);\n      }\n    }, {\n      key: \"once\",\n      value: function once(listener, thisArgs, disposables) {\n        return _once(this.event)(listener, thisArgs, disposables);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this.disposables.dispose();\n      }\n    }]);\n    return ChainableEvent;\n  }();\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n  Event.chain = chain;\n  function fromNodeEventEmitter(emitter, eventName) {\n    var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (id) {\n      return id;\n    };\n    var fn = function fn() {\n      return result.fire(map.apply(void 0, arguments));\n    };\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.on(eventName, fn);\n    };\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeListener(eventName, fn);\n    };\n    var result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  function fromDOMEventEmitter(emitter, eventName) {\n    var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (id) {\n      return id;\n    };\n    var fn = function fn() {\n      return result.fire(map.apply(void 0, arguments));\n    };\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.addEventListener(eventName, fn);\n    };\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeEventListener(eventName, fn);\n    };\n    var result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  function toPromise(event) {\n    return new Promise(function (resolve) {\n      return _once(event)(resolve);\n    });\n  }\n  Event.toPromise = toPromise;\n  function runAndSubscribe(event, handler) {\n    handler(undefined);\n    return event(function (e) {\n      return handler(e);\n    });\n  }\n  Event.runAndSubscribe = runAndSubscribe;\n  function runAndSubscribeWithStore(event, handler) {\n    var store = null;\n    function run(e) {\n      store === null || store === void 0 ? void 0 : store.dispose();\n      store = new DisposableStore();\n      handler(e, store);\n    }\n    run(undefined);\n    var disposable = event(function (e) {\n      return run(e);\n    });\n    return toDisposable(function () {\n      disposable.dispose();\n      store === null || store === void 0 ? void 0 : store.dispose();\n    });\n  }\n  Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n  var EmitterObserver = /*#__PURE__*/function () {\n    function EmitterObserver(obs, store) {\n      var _this = this;\n      _classCallCheck(this, EmitterObserver);\n      this.obs = obs;\n      this._counter = 0;\n      this._hasChanged = false;\n      var options = {\n        onWillAddFirstListener: function onWillAddFirstListener() {\n          obs.addObserver(_this);\n        },\n        onDidRemoveLastListener: function onDidRemoveLastListener() {\n          obs.removeObserver(_this);\n        }\n      };\n      if (!store) {\n        _addLeakageTraceLogic(options);\n      }\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    _createClass(EmitterObserver, [{\n      key: \"beginUpdate\",\n      value: function beginUpdate(_observable) {\n        // console.assert(_observable === this.obs);\n        this._counter++;\n      }\n    }, {\n      key: \"handleChange\",\n      value: function handleChange(_observable, _change) {\n        this._hasChanged = true;\n      }\n    }, {\n      key: \"endUpdate\",\n      value: function endUpdate(_observable) {\n        if (--this._counter === 0) {\n          if (this._hasChanged) {\n            this._hasChanged = false;\n            this.emitter.fire(this.obs.get());\n          }\n        }\n      }\n    }]);\n    return EmitterObserver;\n  }();\n  function fromObservable(obs, store) {\n    var observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event.fromObservable = fromObservable;\n})(Event || (Event = {}));\nvar EventProfiling = /*#__PURE__*/function () {\n  function EventProfiling(name) {\n    _classCallCheck(this, EventProfiling);\n    this.listenerCount = 0;\n    this.invocationCount = 0;\n    this.elapsedOverall = 0;\n    this.durations = [];\n    this.name = \"\".concat(name, \"_\").concat(EventProfiling._idPool++);\n    EventProfiling.all.add(this);\n  }\n  _createClass(EventProfiling, [{\n    key: \"start\",\n    value: function start(listenerCount) {\n      this._stopWatch = new StopWatch(true);\n      this.listenerCount = listenerCount;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._stopWatch) {\n        var elapsed = this._stopWatch.elapsed();\n        this.durations.push(elapsed);\n        this.elapsedOverall += elapsed;\n        this.invocationCount += 1;\n        this._stopWatch = undefined;\n      }\n    }\n  }]);\n  return EventProfiling;\n}();\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nexport { EventProfiling };\nvar _globalLeakWarningThreshold = -1;\nvar LeakageMonitor = /*#__PURE__*/function () {\n  function LeakageMonitor(threshold) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random().toString(18).slice(2, 5);\n    _classCallCheck(this, LeakageMonitor);\n    this.threshold = threshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  _createClass(LeakageMonitor, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _a;\n      (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n  }, {\n    key: \"check\",\n    value: function check(stack, listenerCount) {\n      var _this2 = this;\n      var threshold = this.threshold;\n      if (threshold <= 0 || listenerCount < threshold) {\n        return undefined;\n      }\n      if (!this._stacks) {\n        this._stacks = new Map();\n      }\n      var count = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count + 1);\n      this._warnCountdown -= 1;\n      if (this._warnCountdown <= 0) {\n        // only warn on first exceed and then every time the limit\n        // is exceeded by 50% again\n        this._warnCountdown = threshold * 0.5;\n        // find most frequent listener and print warning\n        var topStack;\n        var topCount = 0;\n        var _iterator = _createForOfIteratorHelper(this._stacks),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              _stack = _step$value[0],\n              _count = _step$value[1];\n            if (!topStack || topCount < _count) {\n              topStack = _stack;\n              topCount = _count;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        console.warn(\"[\".concat(this.name, \"] potential listener LEAK detected, having \").concat(listenerCount, \" listeners already. MOST frequent listener (\").concat(topCount, \"):\"));\n        console.warn(topStack);\n      }\n      return function () {\n        var count = _this2._stacks.get(stack.value) || 0;\n        _this2._stacks.set(stack.value, count - 1);\n      };\n    }\n  }]);\n  return LeakageMonitor;\n}();\nvar Stacktrace = /*#__PURE__*/function () {\n  function Stacktrace(value) {\n    _classCallCheck(this, Stacktrace);\n    this.value = value;\n  }\n  _createClass(Stacktrace, [{\n    key: \"print\",\n    value: function print() {\n      console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var _a;\n      return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n  }]);\n  return Stacktrace;\n}();\nvar Listener = /*#__PURE__*/function () {\n  function Listener(callback, callbackThis, stack) {\n    _classCallCheck(this, Listener);\n    this.callback = callback;\n    this.callbackThis = callbackThis;\n    this.stack = stack;\n    this.subscription = new SafeDisposable();\n  }\n  _createClass(Listener, [{\n    key: \"invoke\",\n    value: function invoke(e) {\n      this.callback.call(this.callbackThis, e);\n    }\n  }]);\n  return Listener;\n}();\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport var Emitter = /*#__PURE__*/function () {\n  function Emitter(options) {\n    _classCallCheck(this, Emitter);\n    var _a, _b, _c, _d, _e;\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;\n    this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;\n    this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n  }\n  _createClass(Emitter, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _a, _b, _c, _d;\n      if (!this._disposed) {\n        this._disposed = true;\n        // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n        // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n        // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n        // the following programming pattern is very popular:\n        //\n        // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n        // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n        // ...later...\n        // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n        if (this._listeners) {\n          if (_enableDisposeWithListenerWarning) {\n            var listeners = Array.from(this._listeners);\n            queueMicrotask(function () {\n              var _a;\n              for (var _i = 0, _listeners = listeners; _i < _listeners.length; _i++) {\n                var listener = _listeners[_i];\n                if (listener.subscription.isset()) {\n                  listener.subscription.unset();\n                  (_a = listener.stack) === null || _a === void 0 ? void 0 : _a.print();\n                }\n              }\n            });\n          }\n          this._listeners.clear();\n        }\n        (_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.clear(this);\n        (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n        (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n      }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n  }, {\n    key: \"event\",\n    get: function get() {\n      var _this3 = this;\n      if (!this._event) {\n        this._event = function (callback, thisArgs, disposables) {\n          var _a, _b, _c;\n          if (!_this3._listeners) {\n            _this3._listeners = new LinkedList();\n          }\n          if (_this3._leakageMon && _this3._listeners.size > _this3._leakageMon.threshold * 3) {\n            console.warn(\"[\".concat(_this3._leakageMon.name, \"] REFUSES to accept new listeners because it exceeded its threshold by far\"));\n            return Disposable.None;\n          }\n          var firstListener = _this3._listeners.isEmpty();\n          if (firstListener && ((_a = _this3._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener)) {\n            _this3._options.onWillAddFirstListener(_this3);\n          }\n          var removeMonitor;\n          var stack;\n          if (_this3._leakageMon && _this3._listeners.size >= Math.ceil(_this3._leakageMon.threshold * 0.2)) {\n            // check and record this emitter for potential leakage\n            stack = Stacktrace.create();\n            removeMonitor = _this3._leakageMon.check(stack, _this3._listeners.size + 1);\n          }\n          if (_enableDisposeWithListenerWarning) {\n            stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n          }\n          var listener = new Listener(callback, thisArgs, stack);\n          var removeListener = _this3._listeners.push(listener);\n          if (firstListener && ((_b = _this3._options) === null || _b === void 0 ? void 0 : _b.onDidAddFirstListener)) {\n            _this3._options.onDidAddFirstListener(_this3);\n          }\n          if ((_c = _this3._options) === null || _c === void 0 ? void 0 : _c.onDidAddListener) {\n            _this3._options.onDidAddListener(_this3, callback, thisArgs);\n          }\n          var result = listener.subscription.set(function () {\n            var _a, _b;\n            removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n            if (!_this3._disposed) {\n              (_b = (_a = _this3._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, _this3);\n              removeListener();\n              if (_this3._options && _this3._options.onDidRemoveLastListener) {\n                var hasListeners = _this3._listeners && !_this3._listeners.isEmpty();\n                if (!hasListeners) {\n                  _this3._options.onDidRemoveLastListener(_this3);\n                }\n              }\n            }\n          });\n          if (disposables instanceof DisposableStore) {\n            disposables.add(result);\n          } else if (Array.isArray(disposables)) {\n            disposables.push(result);\n          }\n          return result;\n        };\n      }\n      return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      var _a, _b;\n      if (this._listeners) {\n        // put all [listener,event]-pairs into delivery queue\n        // then emit all event. an inner/nested event might be\n        // the driver of this\n        if (!this._deliveryQueue) {\n          this._deliveryQueue = new PrivateEventDeliveryQueue();\n        }\n        var _iterator2 = _createForOfIteratorHelper(this._listeners),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var listener = _step2.value;\n            this._deliveryQueue.push(this, listener, event);\n          }\n          // start/stop performance insight collection\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n        this._deliveryQueue.deliver();\n        (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n      }\n    }\n  }, {\n    key: \"hasListeners\",\n    value: function hasListeners() {\n      if (!this._listeners) {\n        return false;\n      }\n      return !this._listeners.isEmpty();\n    }\n  }]);\n  return Emitter;\n}();\nexport var EventDeliveryQueue = /*#__PURE__*/function () {\n  function EventDeliveryQueue() {\n    _classCallCheck(this, EventDeliveryQueue);\n    this._queue = new LinkedList();\n  }\n  _createClass(EventDeliveryQueue, [{\n    key: \"size\",\n    get: function get() {\n      return this._queue.size;\n    }\n  }, {\n    key: \"push\",\n    value: function push(emitter, listener, event) {\n      this._queue.push(new EventDeliveryQueueElement(emitter, listener, event));\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(emitter) {\n      var newQueue = new LinkedList();\n      var _iterator3 = _createForOfIteratorHelper(this._queue),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var element = _step3.value;\n          if (element.emitter !== emitter) {\n            newQueue.push(element);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      this._queue = newQueue;\n    }\n  }, {\n    key: \"deliver\",\n    value: function deliver() {\n      while (this._queue.size > 0) {\n        var element = this._queue.shift();\n        try {\n          element.listener.invoke(element.event);\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n      }\n    }\n  }]);\n  return EventDeliveryQueue;\n}();\n/**\n * An `EventDeliveryQueue` that is guaranteed to be used by a single `Emitter`.\n */\nvar PrivateEventDeliveryQueue = /*#__PURE__*/function (_EventDeliveryQueue) {\n  _inherits(PrivateEventDeliveryQueue, _EventDeliveryQueue);\n  var _super = _createSuper(PrivateEventDeliveryQueue);\n  function PrivateEventDeliveryQueue() {\n    _classCallCheck(this, PrivateEventDeliveryQueue);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PrivateEventDeliveryQueue, [{\n    key: \"clear\",\n    value: function clear(emitter) {\n      // Here we can just clear the entire linked list because\n      // all elements are guaranteed to belong to this emitter\n      this._queue.clear();\n    }\n  }]);\n  return PrivateEventDeliveryQueue;\n}(EventDeliveryQueue);\nvar EventDeliveryQueueElement = /*#__PURE__*/_createClass(function EventDeliveryQueueElement(emitter, listener, event) {\n  _classCallCheck(this, EventDeliveryQueueElement);\n  this.emitter = emitter;\n  this.listener = listener;\n  this.event = event;\n});\nexport var PauseableEmitter = /*#__PURE__*/function (_Emitter) {\n  _inherits(PauseableEmitter, _Emitter);\n  var _super2 = _createSuper(PauseableEmitter);\n  function PauseableEmitter(options) {\n    var _this4;\n    _classCallCheck(this, PauseableEmitter);\n    _this4 = _super2.call(this, options);\n    _this4._isPaused = 0;\n    _this4._eventQueue = new LinkedList();\n    _this4._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    return _this4;\n  }\n  _createClass(PauseableEmitter, [{\n    key: \"pause\",\n    value: function pause() {\n      this._isPaused++;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._isPaused !== 0 && --this._isPaused === 0) {\n        if (this._mergeFn) {\n          // use the merge function to create a single composite\n          // event. make a copy in case firing pauses this emitter\n          if (this._eventQueue.size > 0) {\n            var events = Array.from(this._eventQueue);\n            this._eventQueue.clear();\n            _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, this._mergeFn(events));\n          }\n        } else {\n          // no merging, fire each event individually and test\n          // that this emitter isn't paused halfway through\n          while (!this._isPaused && this._eventQueue.size !== 0) {\n            _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, this._eventQueue.shift());\n          }\n        }\n      }\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      if (this._listeners) {\n        if (this._isPaused !== 0) {\n          this._eventQueue.push(event);\n        } else {\n          _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, event);\n        }\n      }\n    }\n  }]);\n  return PauseableEmitter;\n}(Emitter);\nexport var DebounceEmitter = /*#__PURE__*/function (_PauseableEmitter) {\n  _inherits(DebounceEmitter, _PauseableEmitter);\n  var _super3 = _createSuper(DebounceEmitter);\n  function DebounceEmitter(options) {\n    var _this5;\n    _classCallCheck(this, DebounceEmitter);\n    var _a;\n    _this5 = _super3.call(this, options);\n    _this5._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    return _this5;\n  }\n  _createClass(DebounceEmitter, [{\n    key: \"fire\",\n    value: function fire(event) {\n      var _this6 = this;\n      if (!this._handle) {\n        this.pause();\n        this._handle = setTimeout(function () {\n          _this6._handle = undefined;\n          _this6.resume();\n        }, this._delay);\n      }\n      _get(_getPrototypeOf(DebounceEmitter.prototype), \"fire\", this).call(this, event);\n    }\n  }]);\n  return DebounceEmitter;\n}(PauseableEmitter);\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport var MicrotaskEmitter = /*#__PURE__*/function (_Emitter2) {\n  _inherits(MicrotaskEmitter, _Emitter2);\n  var _super4 = _createSuper(MicrotaskEmitter);\n  function MicrotaskEmitter(options) {\n    var _this7;\n    _classCallCheck(this, MicrotaskEmitter);\n    _this7 = _super4.call(this, options);\n    _this7._queuedEvents = [];\n    _this7._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    return _this7;\n  }\n  _createClass(MicrotaskEmitter, [{\n    key: \"fire\",\n    value: function fire(event) {\n      var _this8 = this;\n      if (!this.hasListeners()) {\n        return;\n      }\n      this._queuedEvents.push(event);\n      if (this._queuedEvents.length === 1) {\n        queueMicrotask(function () {\n          if (_this8._mergeFn) {\n            _get(_getPrototypeOf(MicrotaskEmitter.prototype), \"fire\", _this8).call(_this8, _this8._mergeFn(_this8._queuedEvents));\n          } else {\n            _this8._queuedEvents.forEach(function (e) {\n              return _get(_getPrototypeOf(MicrotaskEmitter.prototype), \"fire\", _this8).call(_this8, e);\n            });\n          }\n          _this8._queuedEvents = [];\n        });\n      }\n    }\n  }]);\n  return MicrotaskEmitter;\n}(Emitter);\nexport var EventMultiplexer = /*#__PURE__*/function () {\n  function EventMultiplexer() {\n    var _this9 = this;\n    _classCallCheck(this, EventMultiplexer);\n    this.hasListeners = false;\n    this.events = [];\n    this.emitter = new Emitter({\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        return _this9.onFirstListenerAdd();\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        return _this9.onLastListenerRemove();\n      }\n    });\n  }\n  _createClass(EventMultiplexer, [{\n    key: \"event\",\n    get: function get() {\n      return this.emitter.event;\n    }\n  }, {\n    key: \"add\",\n    value: function add(event) {\n      var _this10 = this;\n      var e = {\n        event: event,\n        listener: null\n      };\n      this.events.push(e);\n      if (this.hasListeners) {\n        this.hook(e);\n      }\n      var dispose = function dispose() {\n        if (_this10.hasListeners) {\n          _this10.unhook(e);\n        }\n        var idx = _this10.events.indexOf(e);\n        _this10.events.splice(idx, 1);\n      };\n      return toDisposable(onceFn(dispose));\n    }\n  }, {\n    key: \"onFirstListenerAdd\",\n    value: function onFirstListenerAdd() {\n      var _this11 = this;\n      this.hasListeners = true;\n      this.events.forEach(function (e) {\n        return _this11.hook(e);\n      });\n    }\n  }, {\n    key: \"onLastListenerRemove\",\n    value: function onLastListenerRemove() {\n      var _this12 = this;\n      this.hasListeners = false;\n      this.events.forEach(function (e) {\n        return _this12.unhook(e);\n      });\n    }\n  }, {\n    key: \"hook\",\n    value: function hook(e) {\n      var _this13 = this;\n      e.listener = e.event(function (r) {\n        return _this13.emitter.fire(r);\n      });\n    }\n  }, {\n    key: \"unhook\",\n    value: function unhook(e) {\n      if (e.listener) {\n        e.listener.dispose();\n      }\n      e.listener = null;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.emitter.dispose();\n    }\n  }]);\n  return EventMultiplexer;\n}();\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport var EventBufferer = /*#__PURE__*/function () {\n  function EventBufferer() {\n    _classCallCheck(this, EventBufferer);\n    this.buffers = [];\n  }\n  _createClass(EventBufferer, [{\n    key: \"wrapEvent\",\n    value: function wrapEvent(event) {\n      var _this14 = this;\n      return function (listener, thisArgs, disposables) {\n        return event(function (i) {\n          var buffer = _this14.buffers[_this14.buffers.length - 1];\n          if (buffer) {\n            buffer.push(function () {\n              return listener.call(thisArgs, i);\n            });\n          } else {\n            listener.call(thisArgs, i);\n          }\n        }, undefined, disposables);\n      };\n    }\n  }, {\n    key: \"bufferEvents\",\n    value: function bufferEvents(fn) {\n      var buffer = [];\n      this.buffers.push(buffer);\n      var r = fn();\n      this.buffers.pop();\n      buffer.forEach(function (flush) {\n        return flush();\n      });\n      return r;\n    }\n  }]);\n  return EventBufferer;\n}();\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport var Relay = /*#__PURE__*/function () {\n  function Relay() {\n    var _this15 = this;\n    _classCallCheck(this, Relay);\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onDidAddFirstListener: function onDidAddFirstListener() {\n        _this15.listening = true;\n        _this15.inputEventListener = _this15.inputEvent(_this15.emitter.fire, _this15.emitter);\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        _this15.listening = false;\n        _this15.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  _createClass(Relay, [{\n    key: \"input\",\n    set: function set(event) {\n      this.inputEvent = event;\n      if (this.listening) {\n        this.inputEventListener.dispose();\n        this.inputEventListener = event(this.emitter.fire, this.emitter);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.inputEventListener.dispose();\n      this.emitter.dispose();\n    }\n  }]);\n  return Relay;\n}();","map":{"version":3,"names":["onUnexpectedError","once","onceFn","combinedDisposable","Disposable","DisposableStore","SafeDisposable","toDisposable","LinkedList","StopWatch","_enableDisposeWithListenerWarning","_enableSnapshotPotentialLeakWarning","Event","None","_addLeakageTraceLogic","options","origListenerDidAdd","onDidAddListener","stack","Stacktrace","create","count","console","warn","print","defer","event","disposable","debounce","undefined","listener","thisArgs","arguments","length","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","_len","events","Array","_key","apply","_toConsumableArray","reduce","merge","initial","output","onWillAddFirstListener","emitter","fire","onDidRemoveLastListener","Emitter","add","delay","leading","flushOnListenerRemove","leakWarningThreshold","subscription","handle","numDebouncedCalls","doFire","cur","_output","clearTimeout","setTimeout","queueMicrotask","onWillRemoveListener","accumulate","last","push","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","flushAfterTimeout","_buffer","slice","flush","onDidAddFirstListener","ChainableEvent","_classCallCheck","_createClass","key","fn","on","chain","fromNodeEventEmitter","eventName","id","onFirstListenerAdd","onLastListenerRemove","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","runAndSubscribe","handler","runAndSubscribeWithStore","store","run","EmitterObserver","obs","_this","_counter","_hasChanged","addObserver","removeObserver","beginUpdate","_observable","handleChange","_change","endUpdate","get","fromObservable","observer","EventProfiling","name","listenerCount","invocationCount","elapsedOverall","durations","concat","_idPool","all","start","_stopWatch","stop","elapsed","Set","_globalLeakWarningThreshold","LeakageMonitor","threshold","Math","random","toString","_warnCountdown","_a","_stacks","clear","check","_this2","Map","set","topStack","topCount","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","err","f","join","Error","Listener","callback","callbackThis","invoke","_b","_c","_d","_e","_disposed","_options","_leakageMon","_perfMon","_profName","_deliveryQueue","deliveryQueue","_listeners","listeners","from","_i","isset","unset","_this3","_event","size","firstListener","isEmpty","removeMonitor","ceil","hasListeners","isArray","PrivateEventDeliveryQueue","_iterator2","_step2","deliver","EventDeliveryQueue","_queue","EventDeliveryQueueElement","newQueue","_iterator3","_step3","element","shift","_EventDeliveryQueue","_inherits","_super","_createSuper","PauseableEmitter","_Emitter","_super2","_this4","_isPaused","_eventQueue","_mergeFn","pause","resume","_get","_getPrototypeOf","prototype","DebounceEmitter","_PauseableEmitter","_super3","_this5","_delay","_this6","_handle","MicrotaskEmitter","_Emitter2","_super4","_this7","_queuedEvents","_this8","EventMultiplexer","_this9","_this10","hook","unhook","idx","indexOf","splice","_this11","_this12","_this13","r","EventBufferer","buffers","wrapEvent","_this14","bufferEvents","pop","Relay","_this15","listening","inputEvent","inputEventListener"],"sources":["/Users/cadany/WebstormProjects/monaco/node_modules/monaco-editor/esm/vs/base/common/event.js"],"sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { once as onceFn } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, SafeDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire === null || doFire === void 0 ? void 0 : doFire();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n            this.disposables = new DisposableStore();\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn, this.disposables));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn, this.disposables));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn, this.disposables));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event, undefined, this.disposables));\n        }\n        debounce(merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n        dispose() {\n            this.disposables.dispose();\n        }\n    }\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    function runAndSubscribe(event, handler) {\n        handler(undefined);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    function runAndSubscribeWithStore(event, handler) {\n        let store = null;\n        function run(e) {\n            store === null || store === void 0 ? void 0 : store.dispose();\n            store = new DisposableStore();\n            handler(e, store);\n        }\n        run(undefined);\n        const disposable = event(e => run(e));\n        return toDisposable(() => {\n            disposable.dispose();\n            store === null || store === void 0 ? void 0 : store.dispose();\n        });\n    }\n    Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n    class EmitterObserver {\n        constructor(obs, store) {\n            this.obs = obs;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    obs.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    obs.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // console.assert(_observable === this.obs);\n            this._counter++;\n        }\n        handleChange(_observable, _change) {\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            if (--this._counter === 0) {\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this.obs.get());\n                }\n            }\n        }\n    }\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch(true);\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nexport { EventProfiling };\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        var _a;\n        (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nclass Listener {\n    constructor(callback, callbackThis, stack) {\n        this.callback = callback;\n        this.callbackThis = callbackThis;\n        this.stack = stack;\n        this.subscription = new SafeDisposable();\n    }\n    invoke(e) {\n        this.callback.call(this.callbackThis, e);\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a, _b, _c, _d, _e;\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;\n        this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = Array.from(this._listeners);\n                    queueMicrotask(() => {\n                        var _a;\n                        for (const listener of listeners) {\n                            if (listener.subscription.isset()) {\n                                listener.subscription.unset();\n                                (_a = listener.stack) === null || _a === void 0 ? void 0 : _a.print();\n                            }\n                        }\n                    });\n                }\n                this._listeners.clear();\n            }\n            (_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.clear(this);\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (callback, thisArgs, disposables) => {\n                var _a, _b, _c;\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                if (this._leakageMon && this._listeners.size > this._leakageMon.threshold * 3) {\n                    console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n                    return Disposable.None;\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener)) {\n                    this._options.onWillAddFirstListener(this);\n                }\n                let removeMonitor;\n                let stack;\n                if (this._leakageMon && this._listeners.size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                    // check and record this emitter for potential leakage\n                    stack = Stacktrace.create();\n                    removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);\n                }\n                if (_enableDisposeWithListenerWarning) {\n                    stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n                }\n                const listener = new Listener(callback, thisArgs, stack);\n                const removeListener = this._listeners.push(listener);\n                if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidAddFirstListener)) {\n                    this._options.onDidAddFirstListener(this);\n                }\n                if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddListener) {\n                    this._options.onDidAddListener(this, callback, thisArgs);\n                }\n                const result = listener.subscription.set(() => {\n                    var _a, _b;\n                    removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n                    if (!this._disposed) {\n                        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n                        removeListener();\n                        if (this._options && this._options.onDidRemoveLastListener) {\n                            const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                            if (!hasListeners) {\n                                this._options.onDidRemoveLastListener(this);\n                            }\n                        }\n                    }\n                });\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b;\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new PrivateEventDeliveryQueue();\n            }\n            for (const listener of this._listeners) {\n                this._deliveryQueue.push(this, listener, event);\n            }\n            // start/stop performance insight collection\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n            this._deliveryQueue.deliver();\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n    }\n    hasListeners() {\n        if (!this._listeners) {\n            return false;\n        }\n        return !this._listeners.isEmpty();\n    }\n}\nexport class EventDeliveryQueue {\n    constructor() {\n        this._queue = new LinkedList();\n    }\n    get size() {\n        return this._queue.size;\n    }\n    push(emitter, listener, event) {\n        this._queue.push(new EventDeliveryQueueElement(emitter, listener, event));\n    }\n    clear(emitter) {\n        const newQueue = new LinkedList();\n        for (const element of this._queue) {\n            if (element.emitter !== emitter) {\n                newQueue.push(element);\n            }\n        }\n        this._queue = newQueue;\n    }\n    deliver() {\n        while (this._queue.size > 0) {\n            const element = this._queue.shift();\n            try {\n                element.listener.invoke(element.event);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n            }\n        }\n    }\n}\n/**\n * An `EventDeliveryQueue` that is guaranteed to be used by a single `Emitter`.\n */\nclass PrivateEventDeliveryQueue extends EventDeliveryQueue {\n    clear(emitter) {\n        // Here we can just clear the entire linked list because\n        // all elements are guaranteed to belong to this emitter\n        this._queue.clear();\n    }\n}\nclass EventDeliveryQueueElement {\n    constructor(emitter, listener, event) {\n        this.emitter = emitter;\n        this.listener = listener;\n        this.event = event;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\nexport class EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(onceFn(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        if (e.listener) {\n            e.listener.dispose();\n        }\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n"],"mappings":";;;;;;;;;AAAA,SAASA,iBAAiB,QAAQ,aAAa;AAC/C,SAASC,IAAI,IAAIC,MAAM,QAAQ,iBAAiB;AAChD,SAASC,kBAAkB,EAAEC,UAAU,EAAEC,eAAe,EAAEC,cAAc,EAAEC,YAAY,QAAQ,gBAAgB;AAC9G,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,SAAS,QAAQ,gBAAgB;AAC1C;AACA;AACA;AACA,IAAMC,iCAAiC,GAAG,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA,IAAMC,mCAAmC,GAAG,KAAK;AACjD,OAAO,IAAIC,KAAK;AAChB,CAAC,UAAUA,KAAK,EAAE;EACdA,KAAK,CAACC,IAAI,GAAG;IAAA,OAAMT,UAAU,CAACS,IAAI;EAAA;EAClC,SAASC,qBAAqBA,CAACC,OAAO,EAAE;IACpC,IAAIJ,mCAAmC,EAAE;MACrC,IAA0BK,kBAAkB,GAAKD,OAAO,CAAhDE,gBAAgB;MACxB,IAAMC,KAAK,GAAGC,UAAU,CAACC,MAAM,EAAE;MACjC,IAAIC,KAAK,GAAG,CAAC;MACbN,OAAO,CAACE,gBAAgB,GAAG,YAAM;QAC7B,IAAI,EAAEI,KAAK,KAAK,CAAC,EAAE;UACfC,OAAO,CAACC,IAAI,CAAC,4GAA4G,CAAC;UAC1HL,KAAK,CAACM,KAAK,EAAE;QACjB;QACAR,kBAAkB,KAAK,IAAI,IAAIA,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,EAAE;MAChG,CAAC;IACL;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASS,KAAKA,CAACC,KAAK,EAAEC,UAAU,EAAE;IAC9B,OAAOC,SAAQ,CAACF,KAAK,EAAE;MAAA,OAAM,KAAK,CAAC;IAAA,GAAE,CAAC,EAAEG,SAAS,EAAE,IAAI,EAAEA,SAAS,EAAEF,UAAU,CAAC;EACnF;EACAf,KAAK,CAACa,KAAK,GAAGA,KAAK;EACnB;AACJ;AACA;AACA;AACA;EACI,SAASxB,KAAIA,CAACyB,KAAK,EAAE;IACjB,OAAO,UAACI,QAAQ,EAAmC;MAAA,IAAjCC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,IAAI;MAAA,IAAEE,WAAW,GAAAF,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;MAC1C;MACA,IAAIM,OAAO,GAAG,KAAK;MACnB,IAAIC,MAAM,GAAGP,SAAS;MACtBO,MAAM,GAAGV,KAAK,CAAC,UAAAW,CAAC,EAAI;QAChB,IAAIF,OAAO,EAAE;UACT;QACJ,CAAC,MACI,IAAIC,MAAM,EAAE;UACbA,MAAM,CAACE,OAAO,EAAE;QACpB,CAAC,MACI;UACDH,OAAO,GAAG,IAAI;QAClB;QACA,OAAOL,QAAQ,CAACS,IAAI,CAACR,QAAQ,EAAEM,CAAC,CAAC;MACrC,CAAC,EAAE,IAAI,EAAEH,WAAW,CAAC;MACrB,IAAIC,OAAO,EAAE;QACTC,MAAM,CAACE,OAAO,EAAE;MACpB;MACA,OAAOF,MAAM;IACjB,CAAC;EACL;EACAxB,KAAK,CAACX,IAAI,GAAGA,KAAI;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASuC,IAAGA,CAACd,KAAK,EAAEc,GAAG,EAAEb,UAAU,EAAE;IACjC,OAAOc,QAAQ,CAAC,UAACX,QAAQ;MAAA,IAAEC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,IAAI;MAAA,IAAEE,WAAW,GAAAF,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;MAAA,OAAKH,KAAK,CAAC,UAAAgB,CAAC;QAAA,OAAIZ,QAAQ,CAACS,IAAI,CAACR,QAAQ,EAAES,GAAG,CAACE,CAAC,CAAC,CAAC;MAAA,GAAE,IAAI,EAAER,WAAW,CAAC;IAAA,GAAEP,UAAU,CAAC;EAC3I;EACAf,KAAK,CAAC4B,GAAG,GAAGA,IAAG;EACf;AACJ;AACA;AACA;AACA;EACI,SAASG,QAAOA,CAACjB,KAAK,EAAEkB,IAAI,EAAEjB,UAAU,EAAE;IACtC,OAAOc,QAAQ,CAAC,UAACX,QAAQ;MAAA,IAAEC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,IAAI;MAAA,IAAEE,WAAW,GAAAF,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;MAAA,OAAKH,KAAK,CAAC,UAAAgB,CAAC,EAAI;QAAEE,IAAI,CAACF,CAAC,CAAC;QAAEZ,QAAQ,CAACS,IAAI,CAACR,QAAQ,EAAEW,CAAC,CAAC;MAAE,CAAC,EAAE,IAAI,EAAER,WAAW,CAAC;IAAA,GAAEP,UAAU,CAAC;EACpJ;EACAf,KAAK,CAAC+B,OAAO,GAAGA,QAAO;EACvB,SAASE,OAAMA,CAACnB,KAAK,EAAEmB,MAAM,EAAElB,UAAU,EAAE;IACvC,OAAOc,QAAQ,CAAC,UAACX,QAAQ;MAAA,IAAEC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,IAAI;MAAA,IAAEE,WAAW,GAAAF,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;MAAA,OAAKH,KAAK,CAAC,UAAAW,CAAC;QAAA,OAAIQ,MAAM,CAACR,CAAC,CAAC,IAAIP,QAAQ,CAACS,IAAI,CAACR,QAAQ,EAAEM,CAAC,CAAC;MAAA,GAAE,IAAI,EAAEH,WAAW,CAAC;IAAA,GAAEP,UAAU,CAAC;EACnJ;EACAf,KAAK,CAACiC,MAAM,GAAGA,OAAM;EACrB;AACJ;AACA;EACI,SAASC,MAAMA,CAACpB,KAAK,EAAE;IACnB,OAAOA,KAAK;EAChB;EACAd,KAAK,CAACkC,MAAM,GAAGA,MAAM;EACrB,SAASC,GAAGA,CAAA,EAAY;IAAA,SAAAC,IAAA,GAAAhB,SAAA,CAAAC,MAAA,EAARgB,MAAM,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAANF,MAAM,CAAAE,IAAA,IAAAnB,SAAA,CAAAmB,IAAA;IAAA;IAClB,OAAO,UAACrB,QAAQ;MAAA,IAAEC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,IAAI;MAAA,IAAEE,WAAW,GAAAF,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;MAAA,OAAK1B,kBAAkB,CAAAiD,KAAA,SAAAC,kBAAA,CAAIJ,MAAM,CAACT,GAAG,CAAC,UAAAd,KAAK;QAAA,OAAIA,KAAK,CAAC,UAAAW,CAAC;UAAA,OAAIP,QAAQ,CAACS,IAAI,CAACR,QAAQ,EAAEM,CAAC,CAAC;QAAA,GAAE,IAAI,EAAEH,WAAW,CAAC;MAAA,EAAC,EAAC;IAAA;EAC5J;EACAtB,KAAK,CAACmC,GAAG,GAAGA,GAAG;EACf;AACJ;AACA;AACA;AACA;EACI,SAASO,OAAMA,CAAC5B,KAAK,EAAE6B,KAAK,EAAEC,OAAO,EAAE7B,UAAU,EAAE;IAC/C,IAAI8B,MAAM,GAAGD,OAAO;IACpB,OAAOhB,IAAG,CAACd,KAAK,EAAE,UAAAW,CAAC,EAAI;MACnBoB,MAAM,GAAGF,KAAK,CAACE,MAAM,EAAEpB,CAAC,CAAC;MACzB,OAAOoB,MAAM;IACjB,CAAC,EAAE9B,UAAU,CAAC;EAClB;EACAf,KAAK,CAAC0C,MAAM,GAAGA,OAAM;EACrB,SAASb,QAAQA,CAACf,KAAK,EAAEC,UAAU,EAAE;IACjC,IAAIG,QAAQ;IACZ,IAAMf,OAAO,GAAG;MACZ2C,sBAAsB,WAAAA,uBAAA,EAAG;QACrB5B,QAAQ,GAAGJ,KAAK,CAACiC,OAAO,CAACC,IAAI,EAAED,OAAO,CAAC;MAC3C,CAAC;MACDE,uBAAuB,WAAAA,wBAAA,EAAG;QACtB/B,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACQ,OAAO,EAAE;MAC1E;IACJ,CAAC;IACD,IAAI,CAACX,UAAU,EAAE;MACbb,qBAAqB,CAACC,OAAO,CAAC;IAClC;IACA,IAAM4C,OAAO,GAAG,IAAIG,OAAO,CAAC/C,OAAO,CAAC;IACpCY,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACoC,GAAG,CAACJ,OAAO,CAAC;IAC/E,OAAOA,OAAO,CAACjC,KAAK;EACxB;EACA,SAASE,SAAQA,CAACF,KAAK,EAAE6B,KAAK,EAAiG;IAAA,IAA/FS,KAAK,GAAAhC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,GAAG;IAAA,IAAEiC,OAAO,GAAAjC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,KAAK;IAAA,IAAEkC,qBAAqB,GAAAlC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,KAAK;IAAA,IAAEmC,oBAAoB,GAAAnC,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;IAAA,IAAEF,UAAU,GAAAK,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;IACzH,IAAIuC,YAAY;IAChB,IAAIX,MAAM,GAAG5B,SAAS;IACtB,IAAIwC,MAAM,GAAGxC,SAAS;IACtB,IAAIyC,iBAAiB,GAAG,CAAC;IACzB,IAAIC,MAAM;IACV,IAAMxD,OAAO,GAAG;MACZoD,oBAAoB,EAApBA,oBAAoB;MACpBT,sBAAsB,WAAAA,uBAAA,EAAG;QACrBU,YAAY,GAAG1C,KAAK,CAAC,UAAA8C,GAAG,EAAI;UACxBF,iBAAiB,EAAE;UACnBb,MAAM,GAAGF,KAAK,CAACE,MAAM,EAAEe,GAAG,CAAC;UAC3B,IAAIP,OAAO,IAAI,CAACI,MAAM,EAAE;YACpBV,OAAO,CAACC,IAAI,CAACH,MAAM,CAAC;YACpBA,MAAM,GAAG5B,SAAS;UACtB;UACA0C,MAAM,GAAG,SAAAA,OAAA,EAAM;YACX,IAAME,OAAO,GAAGhB,MAAM;YACtBA,MAAM,GAAG5B,SAAS;YAClBwC,MAAM,GAAGxC,SAAS;YAClB,IAAI,CAACoC,OAAO,IAAIK,iBAAiB,GAAG,CAAC,EAAE;cACnCX,OAAO,CAACC,IAAI,CAACa,OAAO,CAAC;YACzB;YACAH,iBAAiB,GAAG,CAAC;UACzB,CAAC;UACD,IAAI,OAAON,KAAK,KAAK,QAAQ,EAAE;YAC3BU,YAAY,CAACL,MAAM,CAAC;YACpBA,MAAM,GAAGM,UAAU,CAACJ,MAAM,EAAEP,KAAK,CAAC;UACtC,CAAC,MACI;YACD,IAAIK,MAAM,KAAKxC,SAAS,EAAE;cACtBwC,MAAM,GAAG,CAAC;cACVO,cAAc,CAACL,MAAM,CAAC;YAC1B;UACJ;QACJ,CAAC,CAAC;MACN,CAAC;MACDM,oBAAoB,WAAAA,qBAAA,EAAG;QACnB,IAAIX,qBAAqB,IAAII,iBAAiB,GAAG,CAAC,EAAE;UAChDC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,EAAE;QAC5D;MACJ,CAAC;MACDV,uBAAuB,WAAAA,wBAAA,EAAG;QACtBU,MAAM,GAAG1C,SAAS;QAClBuC,YAAY,CAAC9B,OAAO,EAAE;MAC1B;IACJ,CAAC;IACD,IAAI,CAACX,UAAU,EAAE;MACbb,qBAAqB,CAACC,OAAO,CAAC;IAClC;IACA,IAAM4C,OAAO,GAAG,IAAIG,OAAO,CAAC/C,OAAO,CAAC;IACpCY,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACoC,GAAG,CAACJ,OAAO,CAAC;IAC/E,OAAOA,OAAO,CAACjC,KAAK;EACxB;EACAd,KAAK,CAACgB,QAAQ,GAAGA,SAAQ;EACzB;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,SAASkD,UAAUA,CAACpD,KAAK,EAAyB;IAAA,IAAvBsC,KAAK,GAAAhC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,CAAC;IAAA,IAAEL,UAAU,GAAAK,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;IAC5C,OAAOjB,KAAK,CAACgB,QAAQ,CAACF,KAAK,EAAE,UAACqD,IAAI,EAAE1C,CAAC,EAAK;MACtC,IAAI,CAAC0C,IAAI,EAAE;QACP,OAAO,CAAC1C,CAAC,CAAC;MACd;MACA0C,IAAI,CAACC,IAAI,CAAC3C,CAAC,CAAC;MACZ,OAAO0C,IAAI;IACf,CAAC,EAAEf,KAAK,EAAEnC,SAAS,EAAE,IAAI,EAAEA,SAAS,EAAEF,UAAU,CAAC;EACrD;EACAf,KAAK,CAACkE,UAAU,GAAGA,UAAU;EAC7B;AACJ;AACA;AACA;AACA;EACI,SAASG,MAAKA,CAACvD,KAAK,EAA0C;IAAA,IAAxCwD,MAAM,GAAAlD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,UAACmD,CAAC,EAAEC,CAAC;MAAA,OAAKD,CAAC,KAAKC,CAAC;IAAA;IAAA,IAAEzD,UAAU,GAAAK,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;IACxD,IAAIwD,SAAS,GAAG,IAAI;IACpB,IAAIC,KAAK;IACT,OAAOzC,OAAM,CAACnB,KAAK,EAAE,UAAA6D,KAAK,EAAI;MAC1B,IAAMC,UAAU,GAAGH,SAAS,IAAI,CAACH,MAAM,CAACK,KAAK,EAAED,KAAK,CAAC;MACrDD,SAAS,GAAG,KAAK;MACjBC,KAAK,GAAGC,KAAK;MACb,OAAOC,UAAU;IACrB,CAAC,EAAE7D,UAAU,CAAC;EAClB;EACAf,KAAK,CAACqE,KAAK,GAAGA,MAAK;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASQ,KAAKA,CAAC/D,KAAK,EAAEgE,GAAG,EAAE/D,UAAU,EAAE;IACnC,OAAO,CACHf,KAAK,CAACiC,MAAM,CAACnB,KAAK,EAAEgE,GAAG,EAAE/D,UAAU,CAAC,EACpCf,KAAK,CAACiC,MAAM,CAACnB,KAAK,EAAE,UAAAW,CAAC;MAAA,OAAI,CAACqD,GAAG,CAACrD,CAAC,CAAC;IAAA,GAAEV,UAAU,CAAC,CAChD;EACL;EACAf,KAAK,CAAC6E,KAAK,GAAGA,KAAK;EACnB;AACJ;AACA;AACA;AACA;EACI,SAASE,MAAMA,CAACjE,KAAK,EAA2C;IAAA,IAAzCkE,iBAAiB,GAAA5D,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,KAAK;IAAA,IAAE6D,OAAO,GAAA7D,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,EAAE;IAC1D,IAAI2D,MAAM,GAAGE,OAAO,CAACC,KAAK,EAAE;IAC5B,IAAIhE,QAAQ,GAAGJ,KAAK,CAAC,UAAAW,CAAC,EAAI;MACtB,IAAIsD,MAAM,EAAE;QACRA,MAAM,CAACX,IAAI,CAAC3C,CAAC,CAAC;MAClB,CAAC,MACI;QACDsB,OAAO,CAACC,IAAI,CAACvB,CAAC,CAAC;MACnB;IACJ,CAAC,CAAC;IACF,IAAM0D,KAAK,GAAG,SAARA,KAAKA,CAAA,EAAS;MAChBJ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAChD,OAAO,CAAC,UAAAN,CAAC;QAAA,OAAIsB,OAAO,CAACC,IAAI,CAACvB,CAAC,CAAC;MAAA,EAAC;MACpFsD,MAAM,GAAG,IAAI;IACjB,CAAC;IACD,IAAMhC,OAAO,GAAG,IAAIG,OAAO,CAAC;MACxBJ,sBAAsB,WAAAA,uBAAA,EAAG;QACrB,IAAI,CAAC5B,QAAQ,EAAE;UACXA,QAAQ,GAAGJ,KAAK,CAAC,UAAAW,CAAC;YAAA,OAAIsB,OAAO,CAACC,IAAI,CAACvB,CAAC,CAAC;UAAA,EAAC;QAC1C;MACJ,CAAC;MACD2D,qBAAqB,WAAAA,sBAAA,EAAG;QACpB,IAAIL,MAAM,EAAE;UACR,IAAIC,iBAAiB,EAAE;YACnBjB,UAAU,CAACoB,KAAK,CAAC;UACrB,CAAC,MACI;YACDA,KAAK,EAAE;UACX;QACJ;MACJ,CAAC;MACDlC,uBAAuB,WAAAA,wBAAA,EAAG;QACtB,IAAI/B,QAAQ,EAAE;UACVA,QAAQ,CAACQ,OAAO,EAAE;QACtB;QACAR,QAAQ,GAAG,IAAI;MACnB;IACJ,CAAC,CAAC;IACF,OAAO6B,OAAO,CAACjC,KAAK;EACxB;EACAd,KAAK,CAAC+E,MAAM,GAAGA,MAAM;EAAC,IAChBM,cAAc;IAChB,SAAAA,eAAYvE,KAAK,EAAE;MAAAwE,eAAA,OAAAD,cAAA;MACf,IAAI,CAACvE,KAAK,GAAGA,KAAK;MAClB,IAAI,CAACQ,WAAW,GAAG,IAAI7B,eAAe,EAAE;IAC5C;IAAC8F,YAAA,CAAAF,cAAA;MAAAG,GAAA;MAAAb,KAAA,EACD,SAAA/C,IAAI6D,EAAE,EAAE;QACJ,OAAO,IAAIJ,cAAc,CAACzD,IAAG,CAAC,IAAI,CAACd,KAAK,EAAE2E,EAAE,EAAE,IAAI,CAACnE,WAAW,CAAC,CAAC;MACpE;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAA5C,QAAQ0D,EAAE,EAAE;QACR,OAAO,IAAIJ,cAAc,CAACtD,QAAO,CAAC,IAAI,CAACjB,KAAK,EAAE2E,EAAE,EAAE,IAAI,CAACnE,WAAW,CAAC,CAAC;MACxE;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAA1C,OAAOwD,EAAE,EAAE;QACP,OAAO,IAAIJ,cAAc,CAACpD,OAAM,CAAC,IAAI,CAACnB,KAAK,EAAE2E,EAAE,EAAE,IAAI,CAACnE,WAAW,CAAC,CAAC;MACvE;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAAjC,OAAOC,KAAK,EAAEC,OAAO,EAAE;QACnB,OAAO,IAAIyC,cAAc,CAAC3C,OAAM,CAAC,IAAI,CAAC5B,KAAK,EAAE6B,KAAK,EAAEC,OAAO,EAAE,IAAI,CAACtB,WAAW,CAAC,CAAC;MACnF;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAAN,MAAA,EAAQ;QACJ,OAAO,IAAIgB,cAAc,CAAChB,MAAK,CAAC,IAAI,CAACvD,KAAK,EAAEG,SAAS,EAAE,IAAI,CAACK,WAAW,CAAC,CAAC;MAC7E;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAA3D,SAAS2B,KAAK,EAAqF;QAAA,IAAnFS,KAAK,GAAAhC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,GAAG;QAAA,IAAEiC,OAAO,GAAAjC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,KAAK;QAAA,IAAEkC,qBAAqB,GAAAlC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,KAAK;QAAA,IAAEmC,oBAAoB,GAAAnC,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;QAC7F,OAAO,IAAIoE,cAAc,CAACrE,SAAQ,CAAC,IAAI,CAACF,KAAK,EAAE6B,KAAK,EAAES,KAAK,EAAEC,OAAO,EAAEC,qBAAqB,EAAEC,oBAAoB,EAAE,IAAI,CAACjC,WAAW,CAAC,CAAC;MACzI;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAAe,GAAGxE,QAAQ,EAAEC,QAAQ,EAAEG,WAAW,EAAE;QAChC,OAAO,IAAI,CAACR,KAAK,CAACI,QAAQ,EAAEC,QAAQ,EAAEG,WAAW,CAAC;MACtD;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAAtF,KAAK6B,QAAQ,EAAEC,QAAQ,EAAEG,WAAW,EAAE;QAClC,OAAOjC,KAAI,CAAC,IAAI,CAACyB,KAAK,CAAC,CAACI,QAAQ,EAAEC,QAAQ,EAAEG,WAAW,CAAC;MAC5D;IAAC;MAAAkE,GAAA;MAAAb,KAAA,EACD,SAAAjD,QAAA,EAAU;QACN,IAAI,CAACJ,WAAW,CAACI,OAAO,EAAE;MAC9B;IAAC;IAAA,OAAA2D,cAAA;EAAA;EAEL,SAASM,KAAKA,CAAC7E,KAAK,EAAE;IAClB,OAAO,IAAIuE,cAAc,CAACvE,KAAK,CAAC;EACpC;EACAd,KAAK,CAAC2F,KAAK,GAAGA,KAAK;EACnB,SAASC,oBAAoBA,CAAC7C,OAAO,EAAE8C,SAAS,EAAkB;IAAA,IAAhBjE,GAAG,GAAAR,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,UAAA0E,EAAE;MAAA,OAAIA,EAAE;IAAA;IAC5D,IAAML,EAAE,GAAG,SAALA,EAAEA,CAAA;MAAA,OAAgBjE,MAAM,CAACwB,IAAI,CAACpB,GAAG,CAAAY,KAAA,SAAApB,SAAA,CAAS,CAAC;IAAA;IACjD,IAAM2E,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAA;MAAA,OAAShD,OAAO,CAAC2C,EAAE,CAACG,SAAS,EAAEJ,EAAE,CAAC;IAAA;IAC1D,IAAMO,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAA;MAAA,OAASjD,OAAO,CAACkD,cAAc,CAACJ,SAAS,EAAEJ,EAAE,CAAC;IAAA;IACxE,IAAMjE,MAAM,GAAG,IAAI0B,OAAO,CAAC;MAAEJ,sBAAsB,EAAEiD,kBAAkB;MAAE9C,uBAAuB,EAAE+C;IAAqB,CAAC,CAAC;IACzH,OAAOxE,MAAM,CAACV,KAAK;EACvB;EACAd,KAAK,CAAC4F,oBAAoB,GAAGA,oBAAoB;EACjD,SAASM,mBAAmBA,CAACnD,OAAO,EAAE8C,SAAS,EAAkB;IAAA,IAAhBjE,GAAG,GAAAR,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,UAAA0E,EAAE;MAAA,OAAIA,EAAE;IAAA;IAC3D,IAAML,EAAE,GAAG,SAALA,EAAEA,CAAA;MAAA,OAAgBjE,MAAM,CAACwB,IAAI,CAACpB,GAAG,CAAAY,KAAA,SAAApB,SAAA,CAAS,CAAC;IAAA;IACjD,IAAM2E,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAA;MAAA,OAAShD,OAAO,CAACoD,gBAAgB,CAACN,SAAS,EAAEJ,EAAE,CAAC;IAAA;IACxE,IAAMO,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAA;MAAA,OAASjD,OAAO,CAACqD,mBAAmB,CAACP,SAAS,EAAEJ,EAAE,CAAC;IAAA;IAC7E,IAAMjE,MAAM,GAAG,IAAI0B,OAAO,CAAC;MAAEJ,sBAAsB,EAAEiD,kBAAkB;MAAE9C,uBAAuB,EAAE+C;IAAqB,CAAC,CAAC;IACzH,OAAOxE,MAAM,CAACV,KAAK;EACvB;EACAd,KAAK,CAACkG,mBAAmB,GAAGA,mBAAmB;EAC/C,SAASG,SAASA,CAACvF,KAAK,EAAE;IACtB,OAAO,IAAIwF,OAAO,CAAC,UAAAC,OAAO;MAAA,OAAIlH,KAAI,CAACyB,KAAK,CAAC,CAACyF,OAAO,CAAC;IAAA,EAAC;EACvD;EACAvG,KAAK,CAACqG,SAAS,GAAGA,SAAS;EAC3B,SAASG,eAAeA,CAAC1F,KAAK,EAAE2F,OAAO,EAAE;IACrCA,OAAO,CAACxF,SAAS,CAAC;IAClB,OAAOH,KAAK,CAAC,UAAAW,CAAC;MAAA,OAAIgF,OAAO,CAAChF,CAAC,CAAC;IAAA,EAAC;EACjC;EACAzB,KAAK,CAACwG,eAAe,GAAGA,eAAe;EACvC,SAASE,wBAAwBA,CAAC5F,KAAK,EAAE2F,OAAO,EAAE;IAC9C,IAAIE,KAAK,GAAG,IAAI;IAChB,SAASC,GAAGA,CAACnF,CAAC,EAAE;MACZkF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACjF,OAAO,EAAE;MAC7DiF,KAAK,GAAG,IAAIlH,eAAe,EAAE;MAC7BgH,OAAO,CAAChF,CAAC,EAAEkF,KAAK,CAAC;IACrB;IACAC,GAAG,CAAC3F,SAAS,CAAC;IACd,IAAMF,UAAU,GAAGD,KAAK,CAAC,UAAAW,CAAC;MAAA,OAAImF,GAAG,CAACnF,CAAC,CAAC;IAAA,EAAC;IACrC,OAAO9B,YAAY,CAAC,YAAM;MACtBoB,UAAU,CAACW,OAAO,EAAE;MACpBiF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACjF,OAAO,EAAE;IACjE,CAAC,CAAC;EACN;EACA1B,KAAK,CAAC0G,wBAAwB,GAAGA,wBAAwB;EAAC,IACpDG,eAAe;IACjB,SAAAA,gBAAYC,GAAG,EAAEH,KAAK,EAAE;MAAA,IAAAI,KAAA;MAAAzB,eAAA,OAAAuB,eAAA;MACpB,IAAI,CAACC,GAAG,GAAGA,GAAG;MACd,IAAI,CAACE,QAAQ,GAAG,CAAC;MACjB,IAAI,CAACC,WAAW,GAAG,KAAK;MACxB,IAAM9G,OAAO,GAAG;QACZ2C,sBAAsB,EAAE,SAAAA,uBAAA,EAAM;UAC1BgE,GAAG,CAACI,WAAW,CAACH,KAAI,CAAC;QACzB,CAAC;QACD9D,uBAAuB,EAAE,SAAAA,wBAAA,EAAM;UAC3B6D,GAAG,CAACK,cAAc,CAACJ,KAAI,CAAC;QAC5B;MACJ,CAAC;MACD,IAAI,CAACJ,KAAK,EAAE;QACRzG,qBAAqB,CAACC,OAAO,CAAC;MAClC;MACA,IAAI,CAAC4C,OAAO,GAAG,IAAIG,OAAO,CAAC/C,OAAO,CAAC;MACnC,IAAIwG,KAAK,EAAE;QACPA,KAAK,CAACxD,GAAG,CAAC,IAAI,CAACJ,OAAO,CAAC;MAC3B;IACJ;IAACwC,YAAA,CAAAsB,eAAA;MAAArB,GAAA;MAAAb,KAAA,EACD,SAAAyC,YAAYC,WAAW,EAAE;QACrB;QACA,IAAI,CAACL,QAAQ,EAAE;MACnB;IAAC;MAAAxB,GAAA;MAAAb,KAAA,EACD,SAAA2C,aAAaD,WAAW,EAAEE,OAAO,EAAE;QAC/B,IAAI,CAACN,WAAW,GAAG,IAAI;MAC3B;IAAC;MAAAzB,GAAA;MAAAb,KAAA,EACD,SAAA6C,UAAUH,WAAW,EAAE;QACnB,IAAI,EAAE,IAAI,CAACL,QAAQ,KAAK,CAAC,EAAE;UACvB,IAAI,IAAI,CAACC,WAAW,EAAE;YAClB,IAAI,CAACA,WAAW,GAAG,KAAK;YACxB,IAAI,CAAClE,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC8D,GAAG,CAACW,GAAG,EAAE,CAAC;UACrC;QACJ;MACJ;IAAC;IAAA,OAAAZ,eAAA;EAAA;EAEL,SAASa,cAAcA,CAACZ,GAAG,EAAEH,KAAK,EAAE;IAChC,IAAMgB,QAAQ,GAAG,IAAId,eAAe,CAACC,GAAG,EAAEH,KAAK,CAAC;IAChD,OAAOgB,QAAQ,CAAC5E,OAAO,CAACjC,KAAK;EACjC;EACAd,KAAK,CAAC0H,cAAc,GAAGA,cAAc;AACzC,CAAC,EAAE1H,KAAK,KAAKA,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;AAAC,IACpB4H,cAAc;EAChB,SAAAA,eAAYC,IAAI,EAAE;IAAAvC,eAAA,OAAAsC,cAAA;IACd,IAAI,CAACE,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACJ,IAAI,MAAAK,MAAA,CAAML,IAAI,OAAAK,MAAA,CAAIN,cAAc,CAACO,OAAO,EAAE,CAAE;IACjDP,cAAc,CAACQ,GAAG,CAACjF,GAAG,CAAC,IAAI,CAAC;EAChC;EAACoC,YAAA,CAAAqC,cAAA;IAAApC,GAAA;IAAAb,KAAA,EACD,SAAA0D,MAAMP,aAAa,EAAE;MACjB,IAAI,CAACQ,UAAU,GAAG,IAAIzI,SAAS,CAAC,IAAI,CAAC;MACrC,IAAI,CAACiI,aAAa,GAAGA,aAAa;IACtC;EAAC;IAAAtC,GAAA;IAAAb,KAAA,EACD,SAAA4D,KAAA,EAAO;MACH,IAAI,IAAI,CAACD,UAAU,EAAE;QACjB,IAAME,OAAO,GAAG,IAAI,CAACF,UAAU,CAACE,OAAO,EAAE;QACzC,IAAI,CAACP,SAAS,CAAC7D,IAAI,CAACoE,OAAO,CAAC;QAC5B,IAAI,CAACR,cAAc,IAAIQ,OAAO;QAC9B,IAAI,CAACT,eAAe,IAAI,CAAC;QACzB,IAAI,CAACO,UAAU,GAAGrH,SAAS;MAC/B;IACJ;EAAC;EAAA,OAAA2G,cAAA;AAAA;AAELA,cAAc,CAACQ,GAAG,GAAG,IAAIK,GAAG,EAAE;AAC9Bb,cAAc,CAACO,OAAO,GAAG,CAAC;AAC1B,SAASP,cAAc;AACvB,IAAIc,2BAA2B,GAAG,CAAC,CAAC;AAAC,IAC/BC,cAAc;EAChB,SAAAA,eAAYC,SAAS,EAAiD;IAAA,IAA/Cf,IAAI,GAAAzG,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAGyH,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,CAAC,EAAE,CAAC,CAAC7D,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IAAAI,eAAA,OAAAqD,cAAA;IAChE,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACf,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACmB,cAAc,GAAG,CAAC;EAC3B;EAACzD,YAAA,CAAAoD,cAAA;IAAAnD,GAAA;IAAAb,KAAA,EACD,SAAAjD,QAAA,EAAU;MACN,IAAIuH,EAAE;MACN,CAACA,EAAE,GAAG,IAAI,CAACC,OAAO,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,KAAK,EAAE;IACvE;EAAC;IAAA3D,GAAA;IAAAb,KAAA,EACD,SAAAyE,MAAM9I,KAAK,EAAEwH,aAAa,EAAE;MAAA,IAAAuB,MAAA;MACxB,IAAMT,SAAS,GAAG,IAAI,CAACA,SAAS;MAChC,IAAIA,SAAS,IAAI,CAAC,IAAId,aAAa,GAAGc,SAAS,EAAE;QAC7C,OAAO3H,SAAS;MACpB;MACA,IAAI,CAAC,IAAI,CAACiI,OAAO,EAAE;QACf,IAAI,CAACA,OAAO,GAAG,IAAII,GAAG,EAAE;MAC5B;MACA,IAAM7I,KAAK,GAAI,IAAI,CAACyI,OAAO,CAACzB,GAAG,CAACnH,KAAK,CAACqE,KAAK,CAAC,IAAI,CAAE;MAClD,IAAI,CAACuE,OAAO,CAACK,GAAG,CAACjJ,KAAK,CAACqE,KAAK,EAAElE,KAAK,GAAG,CAAC,CAAC;MACxC,IAAI,CAACuI,cAAc,IAAI,CAAC;MACxB,IAAI,IAAI,CAACA,cAAc,IAAI,CAAC,EAAE;QAC1B;QACA;QACA,IAAI,CAACA,cAAc,GAAGJ,SAAS,GAAG,GAAG;QACrC;QACA,IAAIY,QAAQ;QACZ,IAAIC,QAAQ,GAAG,CAAC;QAAC,IAAAC,SAAA,GAAAC,0BAAA,CACY,IAAI,CAACT,OAAO;UAAAU,KAAA;QAAA;UAAzC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA2C;YAAA,IAAAC,WAAA,GAAAC,cAAA,CAAAL,KAAA,CAAAjF,KAAA;cAA/BrE,MAAK,GAAA0J,WAAA;cAAEvJ,MAAK,GAAAuJ,WAAA;YACpB,IAAI,CAACR,QAAQ,IAAIC,QAAQ,GAAGhJ,MAAK,EAAE;cAC/B+I,QAAQ,GAAGlJ,MAAK;cAChBmJ,QAAQ,GAAGhJ,MAAK;YACpB;UACJ;QAAC,SAAAyJ,GAAA;UAAAR,SAAA,CAAAjI,CAAA,CAAAyI,GAAA;QAAA;UAAAR,SAAA,CAAAS,CAAA;QAAA;QACDzJ,OAAO,CAACC,IAAI,KAAAuH,MAAA,CAAK,IAAI,CAACL,IAAI,iDAAAK,MAAA,CAA8CJ,aAAa,kDAAAI,MAAA,CAA+CuB,QAAQ,QAAK;QACjJ/I,OAAO,CAACC,IAAI,CAAC6I,QAAQ,CAAC;MAC1B;MACA,OAAO,YAAM;QACT,IAAM/I,KAAK,GAAI4I,MAAI,CAACH,OAAO,CAACzB,GAAG,CAACnH,KAAK,CAACqE,KAAK,CAAC,IAAI,CAAE;QAClD0E,MAAI,CAACH,OAAO,CAACK,GAAG,CAACjJ,KAAK,CAACqE,KAAK,EAAElE,KAAK,GAAG,CAAC,CAAC;MAC5C,CAAC;IACL;EAAC;EAAA,OAAAkI,cAAA;AAAA;AAAA,IAECpI,UAAU;EAKZ,SAAAA,WAAYoE,KAAK,EAAE;IAAAW,eAAA,OAAA/E,UAAA;IACf,IAAI,CAACoE,KAAK,GAAGA,KAAK;EACtB;EAACY,YAAA,CAAAhF,UAAA;IAAAiF,GAAA;IAAAb,KAAA,EACD,SAAA/D,MAAA,EAAQ;MACJF,OAAO,CAACC,IAAI,CAAC,IAAI,CAACgE,KAAK,CAACE,KAAK,CAAC,IAAI,CAAC,CAACK,KAAK,CAAC,CAAC,CAAC,CAACkF,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5D;EAAC;IAAA5E,GAAA;IAAAb,KAAA,EATD,SAAAnE,OAAA,EAAgB;MACZ,IAAIyI,EAAE;MACN,OAAO,IAAI1I,UAAU,CAAC,CAAC0I,EAAE,GAAG,IAAIoB,KAAK,EAAE,CAAC/J,KAAK,MAAM,IAAI,IAAI2I,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE,CAAC;IACvF;EAAC;EAAA,OAAA1I,UAAA;AAAA;AAAA,IAQC+J,QAAQ;EACV,SAAAA,SAAYC,QAAQ,EAAEC,YAAY,EAAElK,KAAK,EAAE;IAAAgF,eAAA,OAAAgF,QAAA;IACvC,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAAClK,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACkD,YAAY,GAAG,IAAI9D,cAAc,EAAE;EAC5C;EAAC6F,YAAA,CAAA+E,QAAA;IAAA9E,GAAA;IAAAb,KAAA,EACD,SAAA8F,OAAOhJ,CAAC,EAAE;MACN,IAAI,CAAC8I,QAAQ,CAAC5I,IAAI,CAAC,IAAI,CAAC6I,YAAY,EAAE/I,CAAC,CAAC;IAC5C;EAAC;EAAA,OAAA6I,QAAA;AAAA;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAapH,OAAO;EAChB,SAAAA,QAAY/C,OAAO,EAAE;IAAAmF,eAAA,OAAApC,OAAA;IACjB,IAAI+F,EAAE,EAAEyB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;IACtB,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,QAAQ,GAAG5K,OAAO;IACvB,IAAI,CAAC6K,WAAW,GAAGtC,2BAA2B,GAAG,CAAC,KAAK,CAACO,EAAE,GAAG,IAAI,CAAC8B,QAAQ,MAAM,IAAI,IAAI9B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC1F,oBAAoB,CAAC,GAAG,IAAIoF,cAAc,CAAC,CAACgC,EAAE,GAAG,CAACD,EAAE,GAAG,IAAI,CAACK,QAAQ,MAAM,IAAI,IAAIL,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACnH,oBAAoB,MAAM,IAAI,IAAIoH,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGjC,2BAA2B,CAAC,GAAGzH,SAAS;IACjU,IAAI,CAACgK,QAAQ,GAAG,CAAC,CAACL,EAAE,GAAG,IAAI,CAACG,QAAQ,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACM,SAAS,IAAI,IAAItD,cAAc,CAAC,IAAI,CAACmD,QAAQ,CAACG,SAAS,CAAC,GAAGjK,SAAS;IAClJ,IAAI,CAACkK,cAAc,GAAG,CAACN,EAAE,GAAG,IAAI,CAACE,QAAQ,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACO,aAAa;EACpG;EAAC7F,YAAA,CAAArC,OAAA;IAAAsC,GAAA;IAAAb,KAAA,EACD,SAAAjD,QAAA,EAAU;MACN,IAAIuH,EAAE,EAAEyB,EAAE,EAAEC,EAAE,EAAEC,EAAE;MAClB,IAAI,CAAC,IAAI,CAACE,SAAS,EAAE;QACjB,IAAI,CAACA,SAAS,GAAG,IAAI;QACrB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI,IAAI,CAACO,UAAU,EAAE;UACjB,IAAIvL,iCAAiC,EAAE;YACnC,IAAMwL,SAAS,GAAGhJ,KAAK,CAACiJ,IAAI,CAAC,IAAI,CAACF,UAAU,CAAC;YAC7CrH,cAAc,CAAC,YAAM;cACjB,IAAIiF,EAAE;cACN,SAAAuC,EAAA,MAAAH,UAAA,GAAuBC,SAAS,EAAAE,EAAA,GAAAH,UAAA,CAAAhK,MAAA,EAAAmK,EAAA,IAAE;gBAA7B,IAAMtK,QAAQ,GAAAmK,UAAA,CAAAG,EAAA;gBACf,IAAItK,QAAQ,CAACsC,YAAY,CAACiI,KAAK,EAAE,EAAE;kBAC/BvK,QAAQ,CAACsC,YAAY,CAACkI,KAAK,EAAE;kBAC7B,CAACzC,EAAE,GAAG/H,QAAQ,CAACZ,KAAK,MAAM,IAAI,IAAI2I,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACrI,KAAK,EAAE;gBACzE;cACJ;YACJ,CAAC,CAAC;UACN;UACA,IAAI,CAACyK,UAAU,CAAClC,KAAK,EAAE;QAC3B;QACA,CAACF,EAAE,GAAG,IAAI,CAACkC,cAAc,MAAM,IAAI,IAAIlC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,KAAK,CAAC,IAAI,CAAC;QAC9E,CAACwB,EAAE,GAAG,CAACD,EAAE,GAAG,IAAI,CAACK,QAAQ,MAAM,IAAI,IAAIL,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACzH,uBAAuB,MAAM,IAAI,IAAI0H,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAChJ,IAAI,CAAC+I,EAAE,CAAC;QAC5I,CAACE,EAAE,GAAG,IAAI,CAACI,WAAW,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAClJ,OAAO,EAAE;MAC7E;IACJ;IACA;AACJ;AACA;AACA;EAHI;IAAA8D,GAAA;IAAAiC,GAAA,EAIA,SAAAA,IAAA,EAAY;MAAA,IAAAkE,MAAA;MACR,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE;QACd,IAAI,CAACA,MAAM,GAAG,UAACrB,QAAQ,EAAEpJ,QAAQ,EAAEG,WAAW,EAAK;UAC/C,IAAI2H,EAAE,EAAEyB,EAAE,EAAEC,EAAE;UACd,IAAI,CAACgB,MAAI,CAACN,UAAU,EAAE;YAClBM,MAAI,CAACN,UAAU,GAAG,IAAIzL,UAAU,EAAE;UACtC;UACA,IAAI+L,MAAI,CAACX,WAAW,IAAIW,MAAI,CAACN,UAAU,CAACQ,IAAI,GAAGF,MAAI,CAACX,WAAW,CAACpC,SAAS,GAAG,CAAC,EAAE;YAC3ElI,OAAO,CAACC,IAAI,KAAAuH,MAAA,CAAKyD,MAAI,CAACX,WAAW,CAACnD,IAAI,gFAA6E;YACnH,OAAOrI,UAAU,CAACS,IAAI;UAC1B;UACA,IAAM6L,aAAa,GAAGH,MAAI,CAACN,UAAU,CAACU,OAAO,EAAE;UAC/C,IAAID,aAAa,KAAK,CAAC7C,EAAE,GAAG0C,MAAI,CAACZ,QAAQ,MAAM,IAAI,IAAI9B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACnG,sBAAsB,CAAC,EAAE;YACxG6I,MAAI,CAACZ,QAAQ,CAACjI,sBAAsB,CAAC6I,MAAI,CAAC;UAC9C;UACA,IAAIK,aAAa;UACjB,IAAI1L,KAAK;UACT,IAAIqL,MAAI,CAACX,WAAW,IAAIW,MAAI,CAACN,UAAU,CAACQ,IAAI,IAAIhD,IAAI,CAACoD,IAAI,CAACN,MAAI,CAACX,WAAW,CAACpC,SAAS,GAAG,GAAG,CAAC,EAAE;YACzF;YACAtI,KAAK,GAAGC,UAAU,CAACC,MAAM,EAAE;YAC3BwL,aAAa,GAAGL,MAAI,CAACX,WAAW,CAAC5B,KAAK,CAAC9I,KAAK,EAAEqL,MAAI,CAACN,UAAU,CAACQ,IAAI,GAAG,CAAC,CAAC;UAC3E;UACA,IAAI/L,iCAAiC,EAAE;YACnCQ,KAAK,GAAGA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAGA,KAAK,GAAGC,UAAU,CAACC,MAAM,EAAE;UAC5E;UACA,IAAMU,QAAQ,GAAG,IAAIoJ,QAAQ,CAACC,QAAQ,EAAEpJ,QAAQ,EAAEb,KAAK,CAAC;UACxD,IAAM2F,cAAc,GAAG0F,MAAI,CAACN,UAAU,CAACjH,IAAI,CAAClD,QAAQ,CAAC;UACrD,IAAI4K,aAAa,KAAK,CAACpB,EAAE,GAAGiB,MAAI,CAACZ,QAAQ,MAAM,IAAI,IAAIL,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACtF,qBAAqB,CAAC,EAAE;YACvGuG,MAAI,CAACZ,QAAQ,CAAC3F,qBAAqB,CAACuG,MAAI,CAAC;UAC7C;UACA,IAAI,CAAChB,EAAE,GAAGgB,MAAI,CAACZ,QAAQ,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACtK,gBAAgB,EAAE;YAC/EsL,MAAI,CAACZ,QAAQ,CAAC1K,gBAAgB,CAACsL,MAAI,EAAEpB,QAAQ,EAAEpJ,QAAQ,CAAC;UAC5D;UACA,IAAMK,MAAM,GAAGN,QAAQ,CAACsC,YAAY,CAAC+F,GAAG,CAAC,YAAM;YAC3C,IAAIN,EAAE,EAAEyB,EAAE;YACVsB,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,aAAa,EAAE;YAC7E,IAAI,CAACL,MAAI,CAACb,SAAS,EAAE;cACjB,CAACJ,EAAE,GAAG,CAACzB,EAAE,GAAG0C,MAAI,CAACZ,QAAQ,MAAM,IAAI,IAAI9B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAChF,oBAAoB,MAAM,IAAI,IAAIyG,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC/I,IAAI,CAACsH,EAAE,EAAE0C,MAAI,CAAC;cAC/I1F,cAAc,EAAE;cAChB,IAAI0F,MAAI,CAACZ,QAAQ,IAAIY,MAAI,CAACZ,QAAQ,CAAC9H,uBAAuB,EAAE;gBACxD,IAAMiJ,YAAY,GAAIP,MAAI,CAACN,UAAU,IAAI,CAACM,MAAI,CAACN,UAAU,CAACU,OAAO,EAAG;gBACpE,IAAI,CAACG,YAAY,EAAE;kBACfP,MAAI,CAACZ,QAAQ,CAAC9H,uBAAuB,CAAC0I,MAAI,CAAC;gBAC/C;cACJ;YACJ;UACJ,CAAC,CAAC;UACF,IAAIrK,WAAW,YAAY7B,eAAe,EAAE;YACxC6B,WAAW,CAAC6B,GAAG,CAAC3B,MAAM,CAAC;UAC3B,CAAC,MACI,IAAIc,KAAK,CAAC6J,OAAO,CAAC7K,WAAW,CAAC,EAAE;YACjCA,WAAW,CAAC8C,IAAI,CAAC5C,MAAM,CAAC;UAC5B;UACA,OAAOA,MAAM;QACjB,CAAC;MACL;MACA,OAAO,IAAI,CAACoK,MAAM;IACtB;IACA;AACJ;AACA;AACA;EAHI;IAAApG,GAAA;IAAAb,KAAA,EAIA,SAAA3B,KAAKlC,KAAK,EAAE;MACR,IAAImI,EAAE,EAAEyB,EAAE;MACV,IAAI,IAAI,CAACW,UAAU,EAAE;QACjB;QACA;QACA;QACA,IAAI,CAAC,IAAI,CAACF,cAAc,EAAE;UACtB,IAAI,CAACA,cAAc,GAAG,IAAIiB,yBAAyB,EAAE;QACzD;QAAC,IAAAC,UAAA,GAAA1C,0BAAA,CACsB,IAAI,CAAC0B,UAAU;UAAAiB,MAAA;QAAA;UAAtC,KAAAD,UAAA,CAAAxC,CAAA,MAAAyC,MAAA,GAAAD,UAAA,CAAAvC,CAAA,IAAAC,IAAA,GAAwC;YAAA,IAA7B7I,QAAQ,GAAAoL,MAAA,CAAA3H,KAAA;YACf,IAAI,CAACwG,cAAc,CAAC/G,IAAI,CAAC,IAAI,EAAElD,QAAQ,EAAEJ,KAAK,CAAC;UACnD;UACA;QAAA,SAAAoJ,GAAA;UAAAmC,UAAA,CAAA5K,CAAA,CAAAyI,GAAA;QAAA;UAAAmC,UAAA,CAAAlC,CAAA;QAAA;QACA,CAAClB,EAAE,GAAG,IAAI,CAACgC,QAAQ,MAAM,IAAI,IAAIhC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACZ,KAAK,CAAC,IAAI,CAAC8C,cAAc,CAACU,IAAI,CAAC;QAC5F,IAAI,CAACV,cAAc,CAACoB,OAAO,EAAE;QAC7B,CAAC7B,EAAE,GAAG,IAAI,CAACO,QAAQ,MAAM,IAAI,IAAIP,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACnC,IAAI,EAAE;MACvE;IACJ;EAAC;IAAA/C,GAAA;IAAAb,KAAA,EACD,SAAAuH,aAAA,EAAe;MACX,IAAI,CAAC,IAAI,CAACb,UAAU,EAAE;QAClB,OAAO,KAAK;MAChB;MACA,OAAO,CAAC,IAAI,CAACA,UAAU,CAACU,OAAO,EAAE;IACrC;EAAC;EAAA,OAAA7I,OAAA;AAAA;AAEL,WAAasJ,kBAAkB;EAC3B,SAAAA,mBAAA,EAAc;IAAAlH,eAAA,OAAAkH,kBAAA;IACV,IAAI,CAACC,MAAM,GAAG,IAAI7M,UAAU,EAAE;EAClC;EAAC2F,YAAA,CAAAiH,kBAAA;IAAAhH,GAAA;IAAAiC,GAAA,EACD,SAAAA,IAAA,EAAW;MACP,OAAO,IAAI,CAACgF,MAAM,CAACZ,IAAI;IAC3B;EAAC;IAAArG,GAAA;IAAAb,KAAA,EACD,SAAAP,KAAKrB,OAAO,EAAE7B,QAAQ,EAAEJ,KAAK,EAAE;MAC3B,IAAI,CAAC2L,MAAM,CAACrI,IAAI,CAAC,IAAIsI,yBAAyB,CAAC3J,OAAO,EAAE7B,QAAQ,EAAEJ,KAAK,CAAC,CAAC;IAC7E;EAAC;IAAA0E,GAAA;IAAAb,KAAA,EACD,SAAAwE,MAAMpG,OAAO,EAAE;MACX,IAAM4J,QAAQ,GAAG,IAAI/M,UAAU,EAAE;MAAC,IAAAgN,UAAA,GAAAjD,0BAAA,CACZ,IAAI,CAAC8C,MAAM;QAAAI,MAAA;MAAA;QAAjC,KAAAD,UAAA,CAAA/C,CAAA,MAAAgD,MAAA,GAAAD,UAAA,CAAA9C,CAAA,IAAAC,IAAA,GAAmC;UAAA,IAAxB+C,OAAO,GAAAD,MAAA,CAAAlI,KAAA;UACd,IAAImI,OAAO,CAAC/J,OAAO,KAAKA,OAAO,EAAE;YAC7B4J,QAAQ,CAACvI,IAAI,CAAC0I,OAAO,CAAC;UAC1B;QACJ;MAAC,SAAA5C,GAAA;QAAA0C,UAAA,CAAAnL,CAAA,CAAAyI,GAAA;MAAA;QAAA0C,UAAA,CAAAzC,CAAA;MAAA;MACD,IAAI,CAACsC,MAAM,GAAGE,QAAQ;IAC1B;EAAC;IAAAnH,GAAA;IAAAb,KAAA,EACD,SAAA4H,QAAA,EAAU;MACN,OAAO,IAAI,CAACE,MAAM,CAACZ,IAAI,GAAG,CAAC,EAAE;QACzB,IAAMiB,OAAO,GAAG,IAAI,CAACL,MAAM,CAACM,KAAK,EAAE;QACnC,IAAI;UACAD,OAAO,CAAC5L,QAAQ,CAACuJ,MAAM,CAACqC,OAAO,CAAChM,KAAK,CAAC;QAC1C,CAAC,CACD,OAAOW,CAAC,EAAE;UACNrC,iBAAiB,CAACqC,CAAC,CAAC;QACxB;MACJ;IACJ;EAAC;EAAA,OAAA+K,kBAAA;AAAA;AAEL;AACA;AACA;AAFA,IAGMJ,yBAAyB,0BAAAY,mBAAA;EAAAC,SAAA,CAAAb,yBAAA,EAAAY,mBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAf,yBAAA;EAAA,SAAAA,0BAAA;IAAA9G,eAAA,OAAA8G,yBAAA;IAAA,OAAAc,MAAA,CAAA1K,KAAA,OAAApB,SAAA;EAAA;EAAAmE,YAAA,CAAA6G,yBAAA;IAAA5G,GAAA;IAAAb,KAAA,EAC3B,SAAAwE,MAAMpG,OAAO,EAAE;MACX;MACA;MACA,IAAI,CAAC0J,MAAM,CAACtD,KAAK,EAAE;IACvB;EAAC;EAAA,OAAAiD,yBAAA;AAAA,EALmCI,kBAAkB;AAAA,IAOpDE,yBAAyB,gBAAAnH,YAAA,CAC3B,SAAAmH,0BAAY3J,OAAO,EAAE7B,QAAQ,EAAEJ,KAAK,EAAE;EAAAwE,eAAA,OAAAoH,yBAAA;EAClC,IAAI,CAAC3J,OAAO,GAAGA,OAAO;EACtB,IAAI,CAAC7B,QAAQ,GAAGA,QAAQ;EACxB,IAAI,CAACJ,KAAK,GAAGA,KAAK;AACtB,CAAC;AAEL,WAAasM,gBAAgB,0BAAAC,QAAA;EAAAJ,SAAA,CAAAG,gBAAA,EAAAC,QAAA;EAAA,IAAAC,OAAA,GAAAH,YAAA,CAAAC,gBAAA;EACzB,SAAAA,iBAAYjN,OAAO,EAAE;IAAA,IAAAoN,MAAA;IAAAjI,eAAA,OAAA8H,gBAAA;IACjBG,MAAA,GAAAD,OAAA,CAAA3L,IAAA,OAAMxB,OAAO;IACboN,MAAA,CAAKC,SAAS,GAAG,CAAC;IAClBD,MAAA,CAAKE,WAAW,GAAG,IAAI7N,UAAU,EAAE;IACnC2N,MAAA,CAAKG,QAAQ,GAAGvN,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACwC,KAAK;IAAC,OAAA4K,MAAA;EACpF;EAAChI,YAAA,CAAA6H,gBAAA;IAAA5H,GAAA;IAAAb,KAAA,EACD,SAAAgJ,MAAA,EAAQ;MACJ,IAAI,CAACH,SAAS,EAAE;IACpB;EAAC;IAAAhI,GAAA;IAAAb,KAAA,EACD,SAAAiJ,OAAA,EAAS;MACL,IAAI,IAAI,CAACJ,SAAS,KAAK,CAAC,IAAI,EAAE,IAAI,CAACA,SAAS,KAAK,CAAC,EAAE;QAChD,IAAI,IAAI,CAACE,QAAQ,EAAE;UACf;UACA;UACA,IAAI,IAAI,CAACD,WAAW,CAAC5B,IAAI,GAAG,CAAC,EAAE;YAC3B,IAAMxJ,MAAM,GAAGC,KAAK,CAACiJ,IAAI,CAAC,IAAI,CAACkC,WAAW,CAAC;YAC3C,IAAI,CAACA,WAAW,CAACtE,KAAK,EAAE;YACxB0E,IAAA,CAAAC,eAAA,CAAAV,gBAAA,CAAAW,SAAA,iBAAApM,IAAA,OAAW,IAAI,CAAC+L,QAAQ,CAACrL,MAAM,CAAC;UACpC;QACJ,CAAC,MACI;UACD;UACA;UACA,OAAO,CAAC,IAAI,CAACmL,SAAS,IAAI,IAAI,CAACC,WAAW,CAAC5B,IAAI,KAAK,CAAC,EAAE;YACnDgC,IAAA,CAAAC,eAAA,CAAAV,gBAAA,CAAAW,SAAA,iBAAApM,IAAA,OAAW,IAAI,CAAC8L,WAAW,CAACV,KAAK,EAAE;UACvC;QACJ;MACJ;IACJ;EAAC;IAAAvH,GAAA;IAAAb,KAAA,EACD,SAAA3B,KAAKlC,KAAK,EAAE;MACR,IAAI,IAAI,CAACuK,UAAU,EAAE;QACjB,IAAI,IAAI,CAACmC,SAAS,KAAK,CAAC,EAAE;UACtB,IAAI,CAACC,WAAW,CAACrJ,IAAI,CAACtD,KAAK,CAAC;QAChC,CAAC,MACI;UACD+M,IAAA,CAAAC,eAAA,CAAAV,gBAAA,CAAAW,SAAA,iBAAApM,IAAA,OAAWb,KAAK;QACpB;MACJ;IACJ;EAAC;EAAA,OAAAsM,gBAAA;AAAA,EAvCiClK,OAAO;AAyC7C,WAAa8K,eAAe,0BAAAC,iBAAA;EAAAhB,SAAA,CAAAe,eAAA,EAAAC,iBAAA;EAAA,IAAAC,OAAA,GAAAf,YAAA,CAAAa,eAAA;EACxB,SAAAA,gBAAY7N,OAAO,EAAE;IAAA,IAAAgO,MAAA;IAAA7I,eAAA,OAAA0I,eAAA;IACjB,IAAI/E,EAAE;IACNkF,MAAA,GAAAD,OAAA,CAAAvM,IAAA,OAAMxB,OAAO;IACbgO,MAAA,CAAKC,MAAM,GAAG,CAACnF,EAAE,GAAG9I,OAAO,CAACiD,KAAK,MAAM,IAAI,IAAI6F,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,GAAG;IAAC,OAAAkF,MAAA;EAC5E;EAAC5I,YAAA,CAAAyI,eAAA;IAAAxI,GAAA;IAAAb,KAAA,EACD,SAAA3B,KAAKlC,KAAK,EAAE;MAAA,IAAAuN,MAAA;MACR,IAAI,CAAC,IAAI,CAACC,OAAO,EAAE;QACf,IAAI,CAACX,KAAK,EAAE;QACZ,IAAI,CAACW,OAAO,GAAGvK,UAAU,CAAC,YAAM;UAC5BsK,MAAI,CAACC,OAAO,GAAGrN,SAAS;UACxBoN,MAAI,CAACT,MAAM,EAAE;QACjB,CAAC,EAAE,IAAI,CAACQ,MAAM,CAAC;MACnB;MACAP,IAAA,CAAAC,eAAA,CAAAE,eAAA,CAAAD,SAAA,iBAAApM,IAAA,OAAWb,KAAK;IACpB;EAAC;EAAA,OAAAkN,eAAA;AAAA,EAfgCZ,gBAAgB;AAiBrD;AACA;AACA;AACA;AACA,WAAamB,gBAAgB,0BAAAC,SAAA;EAAAvB,SAAA,CAAAsB,gBAAA,EAAAC,SAAA;EAAA,IAAAC,OAAA,GAAAtB,YAAA,CAAAoB,gBAAA;EACzB,SAAAA,iBAAYpO,OAAO,EAAE;IAAA,IAAAuO,MAAA;IAAApJ,eAAA,OAAAiJ,gBAAA;IACjBG,MAAA,GAAAD,OAAA,CAAA9M,IAAA,OAAMxB,OAAO;IACbuO,MAAA,CAAKC,aAAa,GAAG,EAAE;IACvBD,MAAA,CAAKhB,QAAQ,GAAGvN,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACwC,KAAK;IAAC,OAAA+L,MAAA;EACpF;EAACnJ,YAAA,CAAAgJ,gBAAA;IAAA/I,GAAA;IAAAb,KAAA,EACD,SAAA3B,KAAKlC,KAAK,EAAE;MAAA,IAAA8N,MAAA;MACR,IAAI,CAAC,IAAI,CAAC1C,YAAY,EAAE,EAAE;QACtB;MACJ;MACA,IAAI,CAACyC,aAAa,CAACvK,IAAI,CAACtD,KAAK,CAAC;MAC9B,IAAI,IAAI,CAAC6N,aAAa,CAACtN,MAAM,KAAK,CAAC,EAAE;QACjC2C,cAAc,CAAC,YAAM;UACjB,IAAI4K,MAAI,CAAClB,QAAQ,EAAE;YACfG,IAAA,CAAAC,eAAA,CAAAS,gBAAA,CAAAR,SAAA,WAAAa,MAAA,EAAAjN,IAAA,CAAAiN,MAAA,EAAWA,MAAI,CAAClB,QAAQ,CAACkB,MAAI,CAACD,aAAa,CAAC;UAChD,CAAC,MACI;YACDC,MAAI,CAACD,aAAa,CAAC5M,OAAO,CAAC,UAAAN,CAAC;cAAA,OAAAoM,IAAA,CAAAC,eAAA,CAAAS,gBAAA,CAAAR,SAAA,WAAAa,MAAA,EAAAjN,IAAA,CAAAiN,MAAA,EAAenN,CAAC;YAAA,CAAC,CAAC;UAClD;UACAmN,MAAI,CAACD,aAAa,GAAG,EAAE;QAC3B,CAAC,CAAC;MACN;IACJ;EAAC;EAAA,OAAAJ,gBAAA;AAAA,EAtBiCrL,OAAO;AAwB7C,WAAa2L,gBAAgB;EACzB,SAAAA,iBAAA,EAAc;IAAA,IAAAC,MAAA;IAAAxJ,eAAA,OAAAuJ,gBAAA;IACV,IAAI,CAAC3C,YAAY,GAAG,KAAK;IACzB,IAAI,CAAC7J,MAAM,GAAG,EAAE;IAChB,IAAI,CAACU,OAAO,GAAG,IAAIG,OAAO,CAAC;MACvBJ,sBAAsB,EAAE,SAAAA,uBAAA;QAAA,OAAMgM,MAAI,CAAC/I,kBAAkB,EAAE;MAAA;MACvD9C,uBAAuB,EAAE,SAAAA,wBAAA;QAAA,OAAM6L,MAAI,CAAC9I,oBAAoB,EAAE;MAAA;IAC9D,CAAC,CAAC;EACN;EAACT,YAAA,CAAAsJ,gBAAA;IAAArJ,GAAA;IAAAiC,GAAA,EACD,SAAAA,IAAA,EAAY;MACR,OAAO,IAAI,CAAC1E,OAAO,CAACjC,KAAK;IAC7B;EAAC;IAAA0E,GAAA;IAAAb,KAAA,EACD,SAAAxB,IAAIrC,KAAK,EAAE;MAAA,IAAAiO,OAAA;MACP,IAAMtN,CAAC,GAAG;QAAEX,KAAK,EAAEA,KAAK;QAAEI,QAAQ,EAAE;MAAK,CAAC;MAC1C,IAAI,CAACmB,MAAM,CAAC+B,IAAI,CAAC3C,CAAC,CAAC;MACnB,IAAI,IAAI,CAACyK,YAAY,EAAE;QACnB,IAAI,CAAC8C,IAAI,CAACvN,CAAC,CAAC;MAChB;MACA,IAAMC,OAAO,GAAG,SAAVA,OAAOA,CAAA,EAAS;QAClB,IAAIqN,OAAI,CAAC7C,YAAY,EAAE;UACnB6C,OAAI,CAACE,MAAM,CAACxN,CAAC,CAAC;QAClB;QACA,IAAMyN,GAAG,GAAGH,OAAI,CAAC1M,MAAM,CAAC8M,OAAO,CAAC1N,CAAC,CAAC;QAClCsN,OAAI,CAAC1M,MAAM,CAAC+M,MAAM,CAACF,GAAG,EAAE,CAAC,CAAC;MAC9B,CAAC;MACD,OAAOvP,YAAY,CAACL,MAAM,CAACoC,OAAO,CAAC,CAAC;IACxC;EAAC;IAAA8D,GAAA;IAAAb,KAAA,EACD,SAAAoB,mBAAA,EAAqB;MAAA,IAAAsJ,OAAA;MACjB,IAAI,CAACnD,YAAY,GAAG,IAAI;MACxB,IAAI,CAAC7J,MAAM,CAACN,OAAO,CAAC,UAAAN,CAAC;QAAA,OAAI4N,OAAI,CAACL,IAAI,CAACvN,CAAC,CAAC;MAAA,EAAC;IAC1C;EAAC;IAAA+D,GAAA;IAAAb,KAAA,EACD,SAAAqB,qBAAA,EAAuB;MAAA,IAAAsJ,OAAA;MACnB,IAAI,CAACpD,YAAY,GAAG,KAAK;MACzB,IAAI,CAAC7J,MAAM,CAACN,OAAO,CAAC,UAAAN,CAAC;QAAA,OAAI6N,OAAI,CAACL,MAAM,CAACxN,CAAC,CAAC;MAAA,EAAC;IAC5C;EAAC;IAAA+D,GAAA;IAAAb,KAAA,EACD,SAAAqK,KAAKvN,CAAC,EAAE;MAAA,IAAA8N,OAAA;MACJ9N,CAAC,CAACP,QAAQ,GAAGO,CAAC,CAACX,KAAK,CAAC,UAAA0O,CAAC;QAAA,OAAID,OAAI,CAACxM,OAAO,CAACC,IAAI,CAACwM,CAAC,CAAC;MAAA,EAAC;IACnD;EAAC;IAAAhK,GAAA;IAAAb,KAAA,EACD,SAAAsK,OAAOxN,CAAC,EAAE;MACN,IAAIA,CAAC,CAACP,QAAQ,EAAE;QACZO,CAAC,CAACP,QAAQ,CAACQ,OAAO,EAAE;MACxB;MACAD,CAAC,CAACP,QAAQ,GAAG,IAAI;IACrB;EAAC;IAAAsE,GAAA;IAAAb,KAAA,EACD,SAAAjD,QAAA,EAAU;MACN,IAAI,CAACqB,OAAO,CAACrB,OAAO,EAAE;IAC1B;EAAC;EAAA,OAAAmN,gBAAA;AAAA;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAaY,aAAa;EACtB,SAAAA,cAAA,EAAc;IAAAnK,eAAA,OAAAmK,aAAA;IACV,IAAI,CAACC,OAAO,GAAG,EAAE;EACrB;EAACnK,YAAA,CAAAkK,aAAA;IAAAjK,GAAA;IAAAb,KAAA,EACD,SAAAgL,UAAU7O,KAAK,EAAE;MAAA,IAAA8O,OAAA;MACb,OAAO,UAAC1O,QAAQ,EAAEC,QAAQ,EAAEG,WAAW,EAAK;QACxC,OAAOR,KAAK,CAAC,UAAAgB,CAAC,EAAI;UACd,IAAMiD,MAAM,GAAG6K,OAAI,CAACF,OAAO,CAACE,OAAI,CAACF,OAAO,CAACrO,MAAM,GAAG,CAAC,CAAC;UACpD,IAAI0D,MAAM,EAAE;YACRA,MAAM,CAACX,IAAI,CAAC;cAAA,OAAMlD,QAAQ,CAACS,IAAI,CAACR,QAAQ,EAAEW,CAAC,CAAC;YAAA,EAAC;UACjD,CAAC,MACI;YACDZ,QAAQ,CAACS,IAAI,CAACR,QAAQ,EAAEW,CAAC,CAAC;UAC9B;QACJ,CAAC,EAAEb,SAAS,EAAEK,WAAW,CAAC;MAC9B,CAAC;IACL;EAAC;IAAAkE,GAAA;IAAAb,KAAA,EACD,SAAAkL,aAAapK,EAAE,EAAE;MACb,IAAMV,MAAM,GAAG,EAAE;MACjB,IAAI,CAAC2K,OAAO,CAACtL,IAAI,CAACW,MAAM,CAAC;MACzB,IAAMyK,CAAC,GAAG/J,EAAE,EAAE;MACd,IAAI,CAACiK,OAAO,CAACI,GAAG,EAAE;MAClB/K,MAAM,CAAChD,OAAO,CAAC,UAAAoD,KAAK;QAAA,OAAIA,KAAK,EAAE;MAAA,EAAC;MAChC,OAAOqK,CAAC;IACZ;EAAC;EAAA,OAAAC,aAAA;AAAA;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,WAAaM,KAAK;EACd,SAAAA,MAAA,EAAc;IAAA,IAAAC,OAAA;IAAA1K,eAAA,OAAAyK,KAAA;IACV,IAAI,CAACE,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,UAAU,GAAGlQ,KAAK,CAACC,IAAI;IAC5B,IAAI,CAACkQ,kBAAkB,GAAG3Q,UAAU,CAACS,IAAI;IACzC,IAAI,CAAC8C,OAAO,GAAG,IAAIG,OAAO,CAAC;MACvBkC,qBAAqB,EAAE,SAAAA,sBAAA,EAAM;QACzB4K,OAAI,CAACC,SAAS,GAAG,IAAI;QACrBD,OAAI,CAACG,kBAAkB,GAAGH,OAAI,CAACE,UAAU,CAACF,OAAI,CAACjN,OAAO,CAACC,IAAI,EAAEgN,OAAI,CAACjN,OAAO,CAAC;MAC9E,CAAC;MACDE,uBAAuB,EAAE,SAAAA,wBAAA,EAAM;QAC3B+M,OAAI,CAACC,SAAS,GAAG,KAAK;QACtBD,OAAI,CAACG,kBAAkB,CAACzO,OAAO,EAAE;MACrC;IACJ,CAAC,CAAC;IACF,IAAI,CAACZ,KAAK,GAAG,IAAI,CAACiC,OAAO,CAACjC,KAAK;EACnC;EAACyE,YAAA,CAAAwK,KAAA;IAAAvK,GAAA;IAAA+D,GAAA,EACD,SAAAA,IAAUzI,KAAK,EAAE;MACb,IAAI,CAACoP,UAAU,GAAGpP,KAAK;MACvB,IAAI,IAAI,CAACmP,SAAS,EAAE;QAChB,IAAI,CAACE,kBAAkB,CAACzO,OAAO,EAAE;QACjC,IAAI,CAACyO,kBAAkB,GAAGrP,KAAK,CAAC,IAAI,CAACiC,OAAO,CAACC,IAAI,EAAE,IAAI,CAACD,OAAO,CAAC;MACpE;IACJ;EAAC;IAAAyC,GAAA;IAAAb,KAAA,EACD,SAAAjD,QAAA,EAAU;MACN,IAAI,CAACyO,kBAAkB,CAACzO,OAAO,EAAE;MACjC,IAAI,CAACqB,OAAO,CAACrB,OAAO,EAAE;IAC1B;EAAC;EAAA,OAAAqO,KAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}