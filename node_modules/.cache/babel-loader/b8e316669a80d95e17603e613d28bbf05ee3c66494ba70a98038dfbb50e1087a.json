{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a, _b;\nclass ResourceMapEntry {\n  constructor(uri, value) {\n    this.uri = uri;\n    this.value = value;\n  }\n}\nclass ResourceMap {\n  constructor(mapOrKeyFn, toKey) {\n    this[_a] = 'ResourceMap';\n    if (mapOrKeyFn instanceof ResourceMap) {\n      this.map = new Map(mapOrKeyFn.map);\n      this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n    } else {\n      this.map = new Map();\n      this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n    }\n  }\n  set(resource, value) {\n    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n    return this;\n  }\n  get(resource) {\n    var _c;\n    return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  has(resource) {\n    return this.map.has(this.toKey(resource));\n  }\n  get size() {\n    return this.map.size;\n  }\n  clear() {\n    this.map.clear();\n  }\n  delete(resource) {\n    return this.map.delete(this.toKey(resource));\n  }\n  forEach(clb, thisArg) {\n    if (typeof thisArg !== 'undefined') {\n      clb = clb.bind(thisArg);\n    }\n    for (const [_, entry] of this.map) {\n      clb(entry.value, entry.uri, this);\n    }\n  }\n  *values() {\n    for (const entry of this.map.values()) {\n      yield entry.value;\n    }\n  }\n  *keys() {\n    for (const entry of this.map.values()) {\n      yield entry.uri;\n    }\n  }\n  *entries() {\n    for (const entry of this.map.values()) {\n      yield [entry.uri, entry.value];\n    }\n  }\n  *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    for (const [, entry] of this.map) {\n      yield [entry.uri, entry.value];\n    }\n  }\n}\nResourceMap.defaultToKey = resource => resource.toString();\nexport { ResourceMap };\nexport class LinkedMap {\n  constructor() {\n    this[_b] = 'LinkedMap';\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state = 0;\n  }\n  clear() {\n    this._map.clear();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state++;\n  }\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n  get size() {\n    return this._size;\n  }\n  get first() {\n    var _c;\n    return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  get last() {\n    var _c;\n    return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    if (touch !== 0 /* Touch.None */) {\n      this.touch(item, touch);\n    }\n    return item.value;\n  }\n  set(key, value) {\n    let touch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let item = this._map.get(key);\n    if (item) {\n      item.value = value;\n      if (touch !== 0 /* Touch.None */) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n      switch (touch) {\n        case 0 /* Touch.None */:\n          this.addItemLast(item);\n          break;\n        case 1 /* Touch.AsOld */:\n          this.addItemFirst(item);\n          break;\n        case 2 /* Touch.AsNew */:\n          this.addItemLast(item);\n          break;\n        default:\n          this.addItemLast(item);\n          break;\n      }\n      this._map.set(key, item);\n      this._size++;\n    }\n    return this;\n  }\n  delete(key) {\n    return !!this.remove(key);\n  }\n  remove(key) {\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    this._map.delete(key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    const item = this._head;\n    this._map.delete(item.key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n      current = current.next;\n    }\n  }\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.key,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.value,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: [current.key, current.value],\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n  trimOld(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._head;\n    let currentSize = this.size;\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n      current = current.next;\n      currentSize--;\n    }\n    this._head = current;\n    this._size = currentSize;\n    if (current) {\n      current.previous = undefined;\n    }\n    this._state++;\n  }\n  addItemFirst(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n    this._head = item;\n    this._state++;\n  }\n  addItemLast(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n    this._tail = item;\n    this._state++;\n  }\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      // This can only happen if size === 1 which is handled\n      // by the case above.\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      // This can only happen if size === 1 which is handled\n      // by the case above.\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n      next.previous = previous;\n      previous.next = next;\n    }\n    item.next = undefined;\n    item.previous = undefined;\n    this._state++;\n  }\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    if (touch !== 1 /* Touch.AsOld */ && touch !== 2 /* Touch.AsNew */) {\n      return;\n    }\n    if (touch === 1 /* Touch.AsOld */) {\n      if (item === this._head) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item\n      if (item === this._tail) {\n        // previous must be defined since item was not head but is tail\n        // So there are more than on item in the map\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      // Insert the node at head\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === 2 /* Touch.AsNew */) {\n      if (item === this._tail) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item.\n      if (item === this._head) {\n        // next must be defined since item was not tail but is head\n        // So there are more than on item in the map\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) => {\n      data.push([key, value]);\n    });\n    return data;\n  }\n  fromJSON(data) {\n    this.clear();\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n}\nexport class LRUCache extends LinkedMap {\n  constructor(limit) {\n    let ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n  get limit() {\n    return this._limit;\n  }\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    return super.get(key, touch);\n  }\n  peek(key) {\n    return super.get(key, 0 /* Touch.None */);\n  }\n\n  set(key, value) {\n    super.set(key, value, 2 /* Touch.AsNew */);\n    this.checkTrim();\n    return this;\n  }\n  checkTrim() {\n    if (this.size > this._limit) {\n      this.trimOld(Math.round(this._limit * this._ratio));\n    }\n  }\n}","map":{"version":3,"names":["_a","_b","ResourceMapEntry","constructor","uri","value","ResourceMap","mapOrKeyFn","toKey","map","Map","defaultToKey","set","resource","get","_c","has","size","clear","delete","forEach","clb","thisArg","bind","_","entry","values","keys","entries","Symbol","toStringTag","iterator","toString","LinkedMap","_map","_head","undefined","_tail","_size","_state","isEmpty","first","last","key","touch","arguments","length","item","next","previous","addItemLast","addItemFirst","remove","removeItem","shift","Error","callbackfn","state","current","result","done","trimOld","newSize","currentSize","toJSON","data","push","fromJSON","LRUCache","limit","ratio","_limit","_ratio","Math","min","max","checkTrim","peek","round"],"sources":["/Users/cadany/WebstormProjects/monaco-editor-sample/node_modules/monaco-editor/esm/vs/base/common/map.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a, _b;\nclass ResourceMapEntry {\n    constructor(uri, value) {\n        this.uri = uri;\n        this.value = value;\n    }\n}\nclass ResourceMap {\n    constructor(mapOrKeyFn, toKey) {\n        this[_a] = 'ResourceMap';\n        if (mapOrKeyFn instanceof ResourceMap) {\n            this.map = new Map(mapOrKeyFn.map);\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n        }\n        else {\n            this.map = new Map();\n            this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n        }\n    }\n    set(resource, value) {\n        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n        return this;\n    }\n    get(resource) {\n        var _c;\n        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(resource) {\n        return this.map.has(this.toKey(resource));\n    }\n    get size() {\n        return this.map.size;\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(resource) {\n        return this.map.delete(this.toKey(resource));\n    }\n    forEach(clb, thisArg) {\n        if (typeof thisArg !== 'undefined') {\n            clb = clb.bind(thisArg);\n        }\n        for (const [_, entry] of this.map) {\n            clb(entry.value, entry.uri, this);\n        }\n    }\n    *values() {\n        for (const entry of this.map.values()) {\n            yield entry.value;\n        }\n    }\n    *keys() {\n        for (const entry of this.map.values()) {\n            yield entry.uri;\n        }\n    }\n    *entries() {\n        for (const entry of this.map.values()) {\n            yield [entry.uri, entry.value];\n        }\n    }\n    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        for (const [, entry] of this.map) {\n            yield [entry.uri, entry.value];\n        }\n    }\n}\nResourceMap.defaultToKey = (resource) => resource.toString();\nexport { ResourceMap };\nexport class LinkedMap {\n    constructor() {\n        this[_b] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        var _c;\n        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    get last() {\n        var _c;\n        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = 0 /* Touch.None */) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== 0 /* Touch.None */) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = 0 /* Touch.None */) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== 0 /* Touch.None */) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case 0 /* Touch.None */:\n                    this.addItemLast(item);\n                    break;\n                case 1 /* Touch.AsOld */:\n                    this.addItemFirst(item);\n                    break;\n                case 2 /* Touch.AsNew */:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== 1 /* Touch.AsOld */ && touch !== 2 /* Touch.AsNew */)) {\n            return;\n        }\n        if (touch === 1 /* Touch.AsOld */) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === 2 /* Touch.AsNew */) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexport class LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get(key, touch = 2 /* Touch.AsNew */) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, 0 /* Touch.None */);\n    }\n    set(key, value) {\n        super.set(key, value, 2 /* Touch.AsNew */);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}