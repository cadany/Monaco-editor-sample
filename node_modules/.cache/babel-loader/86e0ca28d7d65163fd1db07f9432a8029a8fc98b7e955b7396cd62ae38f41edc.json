{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n  constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n    super();\n    this._model = model;\n    this._knownModelVersionId = this._model.getVersionId();\n    this._viewModel = viewModel;\n    this._coordinatesConverter = coordinatesConverter;\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n    this._cursors = new CursorCollection(this.context);\n    this._hasFocus = false;\n    this._isHandling = false;\n    this._compositionState = null;\n    this._columnSelectData = null;\n    this._autoClosedActions = [];\n    this._prevEditOperationType = 0 /* EditOperationType.Other */;\n  }\n\n  dispose() {\n    this._cursors.dispose();\n    this._autoClosedActions = dispose(this._autoClosedActions);\n    super.dispose();\n  }\n  updateConfiguration(cursorConfig) {\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n    this._cursors.updateContext(this.context);\n  }\n  onLineMappingChanged(eventsCollector) {\n    if (this._knownModelVersionId !== this._model.getVersionId()) {\n      // There are model change events that I didn't yet receive.\n      //\n      // This can happen when editing the model, and the view model receives the change events first,\n      // and the view model emits line mapping changed events, all before the cursor gets a chance to\n      // recover from markers.\n      //\n      // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n      return;\n    }\n    // Ensure valid state\n    this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n  }\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n  }\n  _validateAutoClosedActions() {\n    if (this._autoClosedActions.length > 0) {\n      const selections = this._cursors.getSelections();\n      for (let i = 0; i < this._autoClosedActions.length; i++) {\n        const autoClosedAction = this._autoClosedActions[i];\n        if (!autoClosedAction.isValid(selections)) {\n          autoClosedAction.dispose();\n          this._autoClosedActions.splice(i, 1);\n          i--;\n        }\n      }\n    }\n  }\n  // ------ some getters/setters\n  getPrimaryCursorState() {\n    return this._cursors.getPrimaryCursor();\n  }\n  getLastAddedCursorIndex() {\n    return this._cursors.getLastAddedCursorIndex();\n  }\n  getCursorStates() {\n    return this._cursors.getAll();\n  }\n  setStates(eventsCollector, source, reason, states) {\n    let reachedMaxCursorCount = false;\n    const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n    if (states !== null && states.length > multiCursorLimit) {\n      states = states.slice(0, multiCursorLimit);\n      reachedMaxCursorCount = true;\n    }\n    const oldState = CursorModelState.from(this._model, this);\n    this._cursors.setStates(states);\n    this._cursors.normalize();\n    this._columnSelectData = null;\n    this._validateAutoClosedActions();\n    return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n  }\n  setCursorColumnSelectData(columnSelectData) {\n    this._columnSelectData = columnSelectData;\n  }\n  revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n    const viewPositions = this._cursors.getViewPositions();\n    let revealViewRange = null;\n    let revealViewSelections = null;\n    if (viewPositions.length > 1) {\n      revealViewSelections = this._cursors.getViewSelections();\n    } else {\n      revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n    }\n    eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n  }\n  saveState() {\n    const result = [];\n    const selections = this._cursors.getSelections();\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      result.push({\n        inSelectionMode: !selection.isEmpty(),\n        selectionStart: {\n          lineNumber: selection.selectionStartLineNumber,\n          column: selection.selectionStartColumn\n        },\n        position: {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n    }\n    return result;\n  }\n  restoreState(eventsCollector, states) {\n    const desiredSelections = [];\n    for (let i = 0, len = states.length; i < len; i++) {\n      const state = states[i];\n      let positionLineNumber = 1;\n      let positionColumn = 1;\n      // Avoid missing properties on the literal\n      if (state.position && state.position.lineNumber) {\n        positionLineNumber = state.position.lineNumber;\n      }\n      if (state.position && state.position.column) {\n        positionColumn = state.position.column;\n      }\n      let selectionStartLineNumber = positionLineNumber;\n      let selectionStartColumn = positionColumn;\n      // Avoid missing properties on the literal\n      if (state.selectionStart && state.selectionStart.lineNumber) {\n        selectionStartLineNumber = state.selectionStart.lineNumber;\n      }\n      if (state.selectionStart && state.selectionStart.column) {\n        selectionStartColumn = state.selectionStart.column;\n      }\n      desiredSelections.push({\n        selectionStartLineNumber: selectionStartLineNumber,\n        selectionStartColumn: selectionStartColumn,\n        positionLineNumber: positionLineNumber,\n        positionColumn: positionColumn\n      });\n    }\n    this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n    this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n  }\n\n  onModelContentChanged(eventsCollector, event) {\n    if (event instanceof ModelInjectedTextChangedEvent) {\n      // If injected texts change, the view positions of all cursors need to be updated.\n      if (this._isHandling) {\n        // The view positions will be updated when handling finishes\n        return;\n      }\n      // setStates might remove markers, which could trigger a decoration change.\n      // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n      // and an endless recursion happens.\n      // _isHandling prevents that.\n      this._isHandling = true;\n      try {\n        this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n      } finally {\n        this._isHandling = false;\n      }\n    } else {\n      const e = event.rawContentChangedEvent;\n      this._knownModelVersionId = e.versionId;\n      if (this._isHandling) {\n        return;\n      }\n      const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n      this._prevEditOperationType = 0 /* EditOperationType.Other */;\n      if (hadFlushEvent) {\n        // a model.setValue() was called\n        this._cursors.dispose();\n        this._cursors = new CursorCollection(this.context);\n        this._validateAutoClosedActions();\n        this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n      } else {\n        if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n          const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n          if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n            this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n          }\n        } else {\n          const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n          this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n        }\n      }\n    }\n  }\n  getSelection() {\n    return this._cursors.getPrimaryCursor().modelState.selection;\n  }\n  getTopMostViewPosition() {\n    return this._cursors.getTopMostViewPosition();\n  }\n  getBottomMostViewPosition() {\n    return this._cursors.getBottomMostViewPosition();\n  }\n  getCursorColumnSelectData() {\n    if (this._columnSelectData) {\n      return this._columnSelectData;\n    }\n    const primaryCursor = this._cursors.getPrimaryCursor();\n    const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n    const viewPosition = primaryCursor.viewState.position;\n    return {\n      isReal: false,\n      fromViewLineNumber: viewSelectionStart.lineNumber,\n      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n      toViewLineNumber: viewPosition.lineNumber,\n      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition)\n    };\n  }\n  getSelections() {\n    return this._cursors.getSelections();\n  }\n  setSelections(eventsCollector, source, selections, reason) {\n    this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n  }\n  getPrevEditOperationType() {\n    return this._prevEditOperationType;\n  }\n  setPrevEditOperationType(type) {\n    this._prevEditOperationType = type;\n  }\n  // ------ auxiliary handling logic\n  _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n    const autoClosedCharactersDeltaDecorations = [];\n    const autoClosedEnclosingDeltaDecorations = [];\n    for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n      autoClosedCharactersDeltaDecorations.push({\n        range: autoClosedCharactersRanges[i],\n        options: {\n          description: 'auto-closed-character',\n          inlineClassName: 'auto-closed-character',\n          stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        }\n      });\n\n      autoClosedEnclosingDeltaDecorations.push({\n        range: autoClosedEnclosingRanges[i],\n        options: {\n          description: 'auto-closed-enclosing',\n          stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        }\n      });\n    }\n\n    const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n    const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n    this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n  }\n  _executeEditOperation(opResult) {\n    if (!opResult) {\n      // Nothing to execute\n      return;\n    }\n    if (opResult.shouldPushStackElementBefore) {\n      this._model.pushStackElement();\n    }\n    const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n    if (result) {\n      // The commands were applied correctly\n      this._interpretCommandResult(result);\n      // Check for auto-closing closed characters\n      const autoClosedCharactersRanges = [];\n      const autoClosedEnclosingRanges = [];\n      for (let i = 0; i < opResult.commands.length; i++) {\n        const command = opResult.commands[i];\n        if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n          autoClosedCharactersRanges.push(command.closeCharacterRange);\n          autoClosedEnclosingRanges.push(command.enclosingRange);\n        }\n      }\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n      this._prevEditOperationType = opResult.type;\n    }\n    if (opResult.shouldPushStackElementAfter) {\n      this._model.pushStackElement();\n    }\n  }\n  _interpretCommandResult(cursorState) {\n    if (!cursorState || cursorState.length === 0) {\n      cursorState = this._cursors.readSelectionFromMarkers();\n    }\n    this._columnSelectData = null;\n    this._cursors.setSelections(cursorState);\n    this._cursors.normalize();\n  }\n  // -----------------------------------------------------------------------------------------------------------\n  // ----- emitting events\n  _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n    const newState = CursorModelState.from(this._model, this);\n    if (newState.equals(oldState)) {\n      return false;\n    }\n    const selections = this._cursors.getSelections();\n    const viewSelections = this._cursors.getViewSelections();\n    // Let the view get the event first.\n    eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n    // Only after the view has been notified, let the rest of the world know...\n    if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n      const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n      const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n      eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n    }\n    return true;\n  }\n  // -----------------------------------------------------------------------------------------------------------\n  // ----- handlers beyond this point\n  _findAutoClosingPairs(edits) {\n    if (!edits.length) {\n      return null;\n    }\n    const indices = [];\n    for (let i = 0, len = edits.length; i < len; i++) {\n      const edit = edits[i];\n      if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n        return null;\n      }\n      const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n      if (!m) {\n        return null;\n      }\n      const closeChar = m[1];\n      const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n      if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n        return null;\n      }\n      const openChar = autoClosingPairsCandidates[0].open;\n      const closeCharIndex = edit.text.length - m[2].length - 1;\n      const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n      if (openCharIndex === -1) {\n        return null;\n      }\n      indices.push([openCharIndex, closeCharIndex]);\n    }\n    return indices;\n  }\n  executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n    let autoClosingIndices = null;\n    if (source === 'snippet') {\n      autoClosingIndices = this._findAutoClosingPairs(edits);\n    }\n    if (autoClosingIndices) {\n      edits[0]._isTracked = true;\n    }\n    const autoClosedCharactersRanges = [];\n    const autoClosedEnclosingRanges = [];\n    const selections = this._model.pushEditOperations(this.getSelections(), edits, undoEdits => {\n      if (autoClosingIndices) {\n        for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n          const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n          const undoEdit = undoEdits[i];\n          const lineNumber = undoEdit.range.startLineNumber;\n          const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n          const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n          autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n          autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n        }\n      }\n      const selections = cursorStateComputer(undoEdits);\n      if (selections) {\n        // Don't recover the selection from markers because\n        // we know what it should be.\n        this._isHandling = true;\n      }\n      return selections;\n    });\n    if (selections) {\n      this._isHandling = false;\n      this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n    }\n\n    if (autoClosedCharactersRanges.length > 0) {\n      this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n    }\n  }\n  _executeEdit(callback, eventsCollector, source) {\n    let cursorChangeReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (this.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      return;\n    }\n    const oldState = CursorModelState.from(this._model, this);\n    this._cursors.stopTrackingSelections();\n    this._isHandling = true;\n    try {\n      this._cursors.ensureValidState();\n      callback();\n    } catch (err) {\n      onUnexpectedError(err);\n    }\n    this._isHandling = false;\n    this._cursors.startTrackingSelections();\n    this._validateAutoClosedActions();\n    if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n      this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n    }\n  }\n\n  getAutoClosedCharacters() {\n    return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n  }\n  startComposition(eventsCollector) {\n    this._compositionState = new CompositionState(this._model, this.getSelections());\n  }\n  endComposition(eventsCollector, source) {\n    const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n    this._compositionState = null;\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // composition finishes, let's check if we need to auto complete if necessary.\n        this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n      }\n    }, eventsCollector, source);\n  }\n  type(eventsCollector, text, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // If this event is coming straight from the keyboard, look for electric characters and enter\n        const len = text.length;\n        let offset = 0;\n        while (offset < len) {\n          const charLength = strings.nextCharLength(text, offset);\n          const chr = text.substr(offset, charLength);\n          // Here we must interpret each typed character individually\n          this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n          offset += charLength;\n        }\n      } else {\n        this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n      }\n    }, eventsCollector, source);\n  }\n  compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n      // this edit is a no-op\n      if (positionDelta !== 0) {\n        // but it still wants to move the cursor\n        const newSelections = this.getSelections().map(selection => {\n          const position = selection.getPosition();\n          return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n        });\n        this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n      }\n\n      return;\n    }\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    }, eventsCollector, source);\n  }\n  paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n    }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n  }\n\n  cut(eventsCollector, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n    }, eventsCollector, source);\n  }\n  executeCommand(eventsCollector, command, source) {\n    this._executeEdit(() => {\n      this._cursors.killSecondaryCursors();\n      this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n  executeCommands(eventsCollector, commands, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n  static from(model, cursor) {\n    return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n  }\n  constructor(modelVersionId, cursorState) {\n    this.modelVersionId = modelVersionId;\n    this.cursorState = cursorState;\n  }\n  equals(other) {\n    if (!other) {\n      return false;\n    }\n    if (this.modelVersionId !== other.modelVersionId) {\n      return false;\n    }\n    if (this.cursorState.length !== other.cursorState.length) {\n      return false;\n    }\n    for (let i = 0, len = this.cursorState.length; i < len; i++) {\n      if (!this.cursorState[i].equals(other.cursorState[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nclass AutoClosedAction {\n  static getAllAutoClosedCharacters(autoClosedActions) {\n    let autoClosedCharacters = [];\n    for (const autoClosedAction of autoClosedActions) {\n      autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n    }\n    return autoClosedCharacters;\n  }\n  constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n  dispose() {\n    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n    this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n  }\n  getAutoClosedCharactersRanges() {\n    const result = [];\n    for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n      if (decorationRange) {\n        result.push(decorationRange);\n      }\n    }\n    return result;\n  }\n  isValid(selections) {\n    const enclosingRanges = [];\n    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n      if (decorationRange) {\n        enclosingRanges.push(decorationRange);\n        if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n          // Stop tracking if the range becomes multiline...\n          return false;\n        }\n      }\n    }\n    enclosingRanges.sort(Range.compareRangesUsingStarts);\n    selections.sort(Range.compareRangesUsingStarts);\n    for (let i = 0; i < selections.length; i++) {\n      if (i >= enclosingRanges.length) {\n        return false;\n      }\n      if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nclass CommandExecutor {\n  static executeCommands(model, selectionsBefore, commands) {\n    const ctx = {\n      model: model,\n      selectionsBefore: selectionsBefore,\n      trackedRanges: [],\n      trackedRangesDirection: []\n    };\n    const result = this._innerExecuteCommands(ctx, commands);\n    for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n      ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n\n    return result;\n  }\n  static _innerExecuteCommands(ctx, commands) {\n    if (this._arrayIsEmpty(commands)) {\n      return null;\n    }\n    const commandsData = this._getEditOperations(ctx, commands);\n    if (commandsData.operations.length === 0) {\n      return null;\n    }\n    const rawOperations = commandsData.operations;\n    const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n    if (loserCursorsMap.hasOwnProperty('0')) {\n      // These commands are very messed up\n      console.warn('Ignoring commands');\n      return null;\n    }\n    // Remove operations belonging to losing cursors\n    const filteredOperations = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n        filteredOperations.push(rawOperations[i]);\n      }\n    }\n    // TODO@Alex: find a better way to do this.\n    // give the hint that edit operations are tracked to the model\n    if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n      filteredOperations[0]._isTracked = true;\n    }\n    let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, inverseEditOperations => {\n      const groupedInverseEditOperations = [];\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        groupedInverseEditOperations[i] = [];\n      }\n      for (const op of inverseEditOperations) {\n        if (!op.identifier) {\n          // perhaps auto whitespace trim edits\n          continue;\n        }\n        groupedInverseEditOperations[op.identifier.major].push(op);\n      }\n      const minorBasedSorter = (a, b) => {\n        return a.identifier.minor - b.identifier.minor;\n      };\n      const cursorSelections = [];\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        if (groupedInverseEditOperations[i].length > 0) {\n          groupedInverseEditOperations[i].sort(minorBasedSorter);\n          cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n            getInverseEditOperations: () => {\n              return groupedInverseEditOperations[i];\n            },\n            getTrackedSelection: id => {\n              const idx = parseInt(id, 10);\n              const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n              if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n              }\n              return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n            }\n          });\n        } else {\n          cursorSelections[i] = ctx.selectionsBefore[i];\n        }\n      }\n      return cursorSelections;\n    });\n    if (!selectionsAfter) {\n      selectionsAfter = ctx.selectionsBefore;\n    }\n    // Extract losing cursors\n    const losingCursors = [];\n    for (const losingCursorIndex in loserCursorsMap) {\n      if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n        losingCursors.push(parseInt(losingCursorIndex, 10));\n      }\n    }\n    // Sort losing cursors descending\n    losingCursors.sort((a, b) => {\n      return b - a;\n    });\n    // Remove losing cursors\n    for (const losingCursor of losingCursors) {\n      selectionsAfter.splice(losingCursor, 1);\n    }\n    return selectionsAfter;\n  }\n  static _arrayIsEmpty(commands) {\n    for (let i = 0, len = commands.length; i < len; i++) {\n      if (commands[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _getEditOperations(ctx, commands) {\n    let operations = [];\n    let hadTrackedEditOperation = false;\n    for (let i = 0, len = commands.length; i < len; i++) {\n      const command = commands[i];\n      if (command) {\n        const r = this._getEditOperationsFromCommand(ctx, i, command);\n        operations = operations.concat(r.operations);\n        hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n      }\n    }\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n  static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n    // This method acts as a transaction, if the command fails\n    // everything it has done is ignored\n    const operations = [];\n    let operationMinor = 0;\n    const addEditOperation = function (range, text) {\n      let forceMoveMarkers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (Range.isEmpty(range) && text === '') {\n        // This command wants to add a no-op => no thank you\n        return;\n      }\n      operations.push({\n        identifier: {\n          major: majorIdentifier,\n          minor: operationMinor++\n        },\n        range: range,\n        text: text,\n        forceMoveMarkers: forceMoveMarkers,\n        isAutoWhitespaceEdit: command.insertsAutoWhitespace\n      });\n    };\n    let hadTrackedEditOperation = false;\n    const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n      hadTrackedEditOperation = true;\n      addEditOperation(selection, text, forceMoveMarkers);\n    };\n    const trackSelection = (_selection, trackPreviousOnEmpty) => {\n      const selection = Selection.liftSelection(_selection);\n      let stickiness;\n      if (selection.isEmpty()) {\n        if (typeof trackPreviousOnEmpty === 'boolean') {\n          if (trackPreviousOnEmpty) {\n            stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n          } else {\n            stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n          }\n        } else {\n          // Try to lock it with surrounding text\n          const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n          if (selection.startColumn === maxLineColumn) {\n            stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n          } else {\n            stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n          }\n        }\n      } else {\n        stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n      }\n\n      const l = ctx.trackedRanges.length;\n      const id = ctx.model._setTrackedRange(null, selection, stickiness);\n      ctx.trackedRanges[l] = id;\n      ctx.trackedRangesDirection[l] = selection.getDirection();\n      return l.toString();\n    };\n    const editOperationBuilder = {\n      addEditOperation: addEditOperation,\n      addTrackedEditOperation: addTrackedEditOperation,\n      trackSelection: trackSelection\n    };\n    try {\n      command.getEditOperations(ctx.model, editOperationBuilder);\n    } catch (e) {\n      // TODO@Alex use notification service if this should be user facing\n      // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n      onUnexpectedError(e);\n      return {\n        operations: [],\n        hadTrackedEditOperation: false\n      };\n    }\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n  static _getLoserCursorMap(operations) {\n    // This is destructive on the array\n    operations = operations.slice(0);\n    // Sort operations with last one first\n    operations.sort((a, b) => {\n      // Note the minus!\n      return -Range.compareRangesUsingEnds(a.range, b.range);\n    });\n    // Operations can not overlap!\n    const loserCursorsMap = {};\n    for (let i = 1; i < operations.length; i++) {\n      const previousOp = operations[i - 1];\n      const currentOp = operations[i];\n      if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n        let loserMajor;\n        if (previousOp.identifier.major > currentOp.identifier.major) {\n          // previousOp loses the battle\n          loserMajor = previousOp.identifier.major;\n        } else {\n          loserMajor = currentOp.identifier.major;\n        }\n        loserCursorsMap[loserMajor.toString()] = true;\n        for (let j = 0; j < operations.length; j++) {\n          if (operations[j].identifier.major === loserMajor) {\n            operations.splice(j, 1);\n            if (j < i) {\n              i--;\n            }\n            j--;\n          }\n        }\n        if (i > 0) {\n          i--;\n        }\n      }\n    }\n    return loserCursorsMap;\n  }\n}\nclass CompositionLineState {\n  constructor(text, startSelection, endSelection) {\n    this.text = text;\n    this.startSelection = startSelection;\n    this.endSelection = endSelection;\n  }\n}\nclass CompositionState {\n  static _capture(textModel, selections) {\n    const result = [];\n    for (const selection of selections) {\n      if (selection.startLineNumber !== selection.endLineNumber) {\n        return null;\n      }\n      result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n    }\n    return result;\n  }\n  constructor(textModel, selections) {\n    this._original = CompositionState._capture(textModel, selections);\n  }\n  /**\n   * Returns the inserted text during this composition.\n   * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n   */\n  deduceOutcome(textModel, selections) {\n    if (!this._original) {\n      return null;\n    }\n    const current = CompositionState._capture(textModel, selections);\n    if (!current) {\n      return null;\n    }\n    if (this._original.length !== current.length) {\n      return null;\n    }\n    const result = [];\n    for (let i = 0, len = this._original.length; i < len; i++) {\n      result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n    }\n    return result;\n  }\n  static _deduceOutcome(original, current) {\n    const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n    const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n    const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n    const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n    return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n  }\n}","map":{"version":3,"names":["onUnexpectedError","strings","CursorCollection","CursorState","EditOperationResult","CursorContext","DeleteOperations","CompositionOutcome","TypeOperations","TypeWithAutoClosingCommand","Range","Selection","ModelInjectedTextChangedEvent","ViewCursorStateChangedEvent","ViewRevealRangeRequestEvent","dispose","Disposable","CursorStateChangedEvent","CursorsController","constructor","model","viewModel","coordinatesConverter","cursorConfig","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","context","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateConfiguration","updateContext","onLineMappingChanged","eventsCollector","setStates","getCursorStates","setHasFocus","hasFocus","_validateAutoClosedActions","length","selections","getSelections","i","autoClosedAction","isValid","splice","getPrimaryCursorState","getPrimaryCursor","getLastAddedCursorIndex","getAll","source","reason","states","reachedMaxCursorCount","multiCursorLimit","slice","oldState","CursorModelState","from","normalize","_emitStateChangedIfNecessary","setCursorColumnSelectData","columnSelectData","revealPrimary","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","fromPositions","emitViewEvent","saveState","result","len","selection","push","inSelectionMode","isEmpty","selectionStart","lineNumber","selectionStartLineNumber","column","selectionStartColumn","position","positionLineNumber","positionColumn","restoreState","desiredSelections","state","fromModelSelections","onModelContentChanged","event","e","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","resultingSelection","cursorState","isUndoing","isRedoing","selectionsFromMarkers","readSelectionFromMarkers","getSelection","modelState","getTopMostViewPosition","getBottomMostViewPosition","getCursorColumnSelectData","primaryCursor","viewSelectionStart","viewState","getStartPosition","viewPosition","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","setSelections","getPrevEditOperationType","setPrevEditOperationType","type","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","range","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","_executeEditOperation","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","newState","equals","viewSelections","some","newCursorState","oldSelections","map","s","oldModelVersionId","modelVersionId","emitOutgoingEvent","_findAutoClosingPairs","edits","indices","edit","text","indexOf","m","match","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","get","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","executeEdits","cursorStateComputer","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","startLineNumber","startColumn","_executeEdit","callback","cursorChangeReason","arguments","undefined","readOnly","stopTrackingSelections","ensureValidState","err","startTrackingSelections","getAutoClosedCharacters","getAllAutoClosedCharacters","startComposition","CompositionState","endComposition","compositionOutcome","deduceOutcome","compositionEndWithInterceptors","offset","charLength","nextCharLength","chr","substr","typeWithInterceptors","typeWithoutInterceptors","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","newSelections","getPosition","paste","pasteOnNewLine","multicursorText","cut","executeCommand","killSecondaryCursors","cursor","other","autoClosedActions","autoClosedCharacters","concat","getAutoClosedCharactersRanges","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","endLineNumber","sort","compareRangesUsingStarts","strictContainsRange","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_setTrackedRange","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","a","b","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","_getTrackedRange","endColumn","losingCursors","losingCursorIndex","losingCursor","r","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getDirection","editOperationBuilder","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","isBefore","getEndPosition","loserMajor","j","CompositionLineState","startSelection","endSelection","_capture","textModel","getLineContent","_original","current","_deduceOutcome","original","commonPrefix","Math","min","commonPrefixLength","commonSuffix","commonSuffixLength","deletedText","substring","insertedText"],"sources":["/Users/cadany/WebstormProjects/monaco/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}