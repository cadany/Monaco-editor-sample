{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arrays.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  constructor(_languageFeaturesService, _outlineModelService) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Object.create(null);\n    super(options);\n    this._languageFeaturesService = _languageFeaturesService;\n    this._outlineModelService = _outlineModelService;\n    this.options = options;\n    this.options.canAcceptInBackground = true;\n  }\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n  provideWithTextEditor(context, picker, token) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n    if (!model) {\n      return Disposable.None;\n    }\n    // Provide symbols from model if available in registry\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token);\n    }\n    // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    const disposables = new DisposableStore();\n    // Generic pick for not having any symbol information\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n    // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n    (() => __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n    }))();\n    return disposables;\n  }\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14 /* SymbolKind.String */\n    }];\n    picker.ariaLabel = label;\n  }\n  waitForLanguageSymbolRegistry(model, disposables) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n        return true;\n      }\n      const symbolProviderRegistryPromise = new DeferredPromise();\n      // Resolve promise when registry knows model\n      const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n          symbolProviderListener.dispose();\n          symbolProviderRegistryPromise.complete(true);\n        }\n      }));\n      // Resolve promise when we get disposed too\n      disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n      return symbolProviderRegistryPromise.p;\n    });\n  }\n  doProvideWithEditorSymbols(context, model, picker, token) {\n    var _a;\n    const editor = context.editor;\n    const disposables = new DisposableStore();\n    // Goto symbol once picked\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    }));\n    // Goto symbol side by side if enabled\n    disposables.add(picker.onDidTriggerItemButton(_ref => {\n      let {\n        item\n      } = _ref;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    }));\n    // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n    const symbolsPromise = this.getDocumentSymbols(model, token);\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const updatePickerItems = positionToEnclose => __awaiter(this, void 0, void 0, function* () {\n      // Cancel any previous ask for picks and busy\n      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n      picker.busy = false;\n      // Create new cancellation source for this run\n      picksCts = new CancellationTokenSource(token);\n      // Collect symbol picks\n      picker.busy = true;\n      try {\n        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n        const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n        if (token.isCancellationRequested) {\n          return;\n        }\n        if (items.length > 0) {\n          picker.items = items;\n          if (positionToEnclose && query.original.length === 0) {\n            const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n            if (candidate) {\n              picker.activeItems = [candidate];\n            }\n          }\n        } else {\n          if (query.original.length > 0) {\n            this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n          } else {\n            this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n          }\n        }\n      } finally {\n        if (!token.isCancellationRequested) {\n          picker.busy = false;\n        }\n      }\n    });\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n    updatePickerItems((_a = editor.getSelection()) === null || _a === void 0 ? void 0 : _a.getPosition());\n    // Reveal and decorate when active item changes\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n      if (item && item.range) {\n        // Reveal\n        editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n        // Decorate\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n  doGetSymbolPicks(symbolsPromise, query, options, token) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const symbols = yield symbolsPromise;\n      if (token.isCancellationRequested) {\n        return [];\n      }\n      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n      const filterPos = filterBySymbolKind ? 1 : 0;\n      // Split between symbol and container query\n      let symbolQuery;\n      let containerQuery;\n      if (query.values && query.values.length > 1) {\n        symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n        containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n      } else {\n        symbolQuery = query;\n      }\n      // Convert to symbol picks and apply filtering\n      let buttons;\n      const openSideBySideDirection = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) === null || _b === void 0 ? void 0 : _b.call(_a);\n      if (openSideBySideDirection) {\n        buttons = [{\n          iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n          tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n        }];\n      }\n      const filteredSymbolPicks = [];\n      for (let index = 0; index < symbols.length; index++) {\n        const symbol = symbols[index];\n        const symbolLabel = trim(symbol.name);\n        const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n        let containerLabel = symbol.containerName;\n        if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n          if (containerLabel) {\n            containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n          } else {\n            containerLabel = options.extraContainerLabel;\n          }\n        }\n        let symbolScore = undefined;\n        let symbolMatches = undefined;\n        let containerScore = undefined;\n        let containerMatches = undefined;\n        if (query.original.length > filterPos) {\n          // First: try to score on the entire query, it is possible that\n          // the symbol matches perfectly (e.g. searching for \"change log\"\n          // can be a match on a markdown symbol \"change log\"). In that\n          // case we want to skip the container query altogether.\n          let skipContainerQuery = false;\n          if (symbolQuery !== query) {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), {\n              values: undefined /* disable multi-query support */\n            }), filterPos, symbolLabelIconOffset);\n            if (typeof symbolScore === 'number') {\n              skipContainerQuery = true; // since we consumed the query, skip any container matching\n            }\n          }\n          // Otherwise: score on the symbol query and match on the container later\n          if (typeof symbolScore !== 'number') {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n            if (typeof symbolScore !== 'number') {\n              continue;\n            }\n          }\n          // Score by container if specified\n          if (!skipContainerQuery && containerQuery) {\n            if (containerLabel && containerQuery.original.length > 0) {\n              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n            }\n            if (typeof containerScore !== 'number') {\n              continue;\n            }\n            if (typeof symbolScore === 'number') {\n              symbolScore += containerScore; // boost symbolScore by containerScore\n            }\n          }\n        }\n\n        const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n        filteredSymbolPicks.push({\n          index,\n          kind: symbol.kind,\n          score: symbolScore,\n          label: symbolLabelWithIcon,\n          ariaLabel: symbolLabel,\n          description: containerLabel,\n          highlights: deprecated ? undefined : {\n            label: symbolMatches,\n            description: containerMatches\n          },\n          range: {\n            selection: Range.collapseToStart(symbol.selectionRange),\n            decoration: symbol.range\n          },\n          strikethrough: deprecated,\n          buttons\n        });\n      }\n      // Sort by score\n      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));\n      // Add separator for types\n      // - @  only total number of symbols\n      // - @: grouped by symbol kind\n      let symbolPicks = [];\n      if (filterBySymbolKind) {\n        let lastSymbolKind = undefined;\n        let lastSeparator = undefined;\n        let lastSymbolKindCounter = 0;\n        function updateLastSeparatorLabel() {\n          if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n          }\n        }\n        for (const symbolPick of sortedFilteredSymbolPicks) {\n          // Found new kind\n          if (lastSymbolKind !== symbolPick.kind) {\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n            lastSymbolKind = symbolPick.kind;\n            lastSymbolKindCounter = 1;\n            // Add new separator for new kind\n            lastSeparator = {\n              type: 'separator'\n            };\n            symbolPicks.push(lastSeparator);\n          }\n          // Existing kind, keep counting\n          else {\n            lastSymbolKindCounter++;\n          }\n          // Add to final result\n          symbolPicks.push(symbolPick);\n        }\n        // Update last separator with number of symbols we found for kind\n        updateLastSeparatorLabel();\n      } else if (sortedFilteredSymbolPicks.length > 0) {\n        symbolPicks = [{\n          label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n          type: 'separator'\n        }, ...sortedFilteredSymbolPicks];\n      }\n      return symbolPicks;\n    });\n  }\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n    return 0;\n  }\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    // Sort by type first if scoped search\n    const result = kindA.localeCompare(kindB);\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n    return result;\n  }\n  getDocumentSymbols(document, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = yield this._outlineModelService.getOrCreate(document, token);\n      return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    });\n  }\n};\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;\nAbstractGotoSymbolQuickAccessProvider = __decorate([__param(0, ILanguageFeaturesService), __param(1, IOutlineModelService)], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n  [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n  [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n  [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n  [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n  [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n  [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n  [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n  [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n  [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n  [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n  [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n  [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n  [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n  [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n  [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n  [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n  [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n  [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n  [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n  [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n  [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n  [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n  [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n  [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","DeferredPromise","CancellationTokenSource","Codicon","ThemeIcon","pieceToQuery","prepareQuery","scoreFuzzy2","Disposable","DisposableStore","toDisposable","format","trim","Range","SymbolKinds","IOutlineModelService","AbstractEditorNavigationQuickAccessProvider","localize","ILanguageFeaturesService","findLast","AbstractGotoSymbolQuickAccessProvider","constructor","_languageFeaturesService","_outlineModelService","options","undefined","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","editor","model","getModel","documentSymbolProvider","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","disposables","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","complete","p","_a","onDidAccept","event","item","selectedItems","range","gotoLocation","selection","keyMods","preserveFocus","inBackground","hide","onDidTriggerItemButton","_ref","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","updatePickerItems","positionToEnclose","busy","query","substr","PREFIX","doGetSymbolPicks","original","candidate","Boolean","type","containsPosition","decoration","activeItems","onDidChangeValue","getSelection","getPosition","onDidChangeActive","revealRangeInCenter","addDecorations","_b","symbols","filterBySymbolKind","indexOf","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","values","slice","buttons","openSideBySideDirection","call","iconClass","asClassName","splitHorizontal","splitVertical","tooltip","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","toIcon","id","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","assign","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","strikethrough","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","kindA","kindB","localeCompare","document","getOrCreate","asListOfDocumentSymbols","PREFIX_BY_CATEGORY"],"sources":["/Users/cadany/WebstormProjects/monaco-editor-sample/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arrays.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n        super(options);\n        this._languageFeaturesService = _languageFeaturesService;\n        this._outlineModelService = _outlineModelService;\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        }))();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* SymbolKind.String */ }];\n        picker.ariaLabel = label;\n    }\n    waitForLanguageSymbolRegistry(model, disposables) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                return true;\n            }\n            const symbolProviderRegistryPromise = new DeferredPromise();\n            // Resolve promise when registry knows model\n            const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n                if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                    symbolProviderListener.dispose();\n                    symbolProviderRegistryPromise.complete(true);\n                }\n            }));\n            // Resolve promise when we get disposed too\n            disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n            return symbolProviderRegistryPromise.p;\n        });\n    }\n    doProvideWithEditorSymbols(context, model, picker, token) {\n        var _a;\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = (positionToEnclose) => __awaiter(this, void 0, void 0, function* () {\n            // Cancel any previous ask for picks and busy\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n                const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                    if (positionToEnclose && query.original.length === 0) {\n                        const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n                        if (candidate) {\n                            picker.activeItems = [candidate];\n                        }\n                    }\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        });\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n        updatePickerItems((_a = editor.getSelection()) === null || _a === void 0 ? void 0 : _a.getPosition());\n        // Reveal and decorate when active item changes\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    doGetSymbolPicks(symbolsPromise, query, options, token) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbols = yield symbolsPromise;\n            if (token.isCancellationRequested) {\n                return [];\n            }\n            const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n            const filterPos = filterBySymbolKind ? 1 : 0;\n            // Split between symbol and container query\n            let symbolQuery;\n            let containerQuery;\n            if (query.values && query.values.length > 1) {\n                symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n                containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n            }\n            else {\n                symbolQuery = query;\n            }\n            // Convert to symbol picks and apply filtering\n            let buttons;\n            const openSideBySideDirection = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) === null || _b === void 0 ? void 0 : _b.call(_a);\n            if (openSideBySideDirection) {\n                buttons = [{\n                        iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n                        tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                    }];\n            }\n            const filteredSymbolPicks = [];\n            for (let index = 0; index < symbols.length; index++) {\n                const symbol = symbols[index];\n                const symbolLabel = trim(symbol.name);\n                const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n                const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n                let containerLabel = symbol.containerName;\n                if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n                    if (containerLabel) {\n                        containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n                    }\n                    else {\n                        containerLabel = options.extraContainerLabel;\n                    }\n                }\n                let symbolScore = undefined;\n                let symbolMatches = undefined;\n                let containerScore = undefined;\n                let containerMatches = undefined;\n                if (query.original.length > filterPos) {\n                    // First: try to score on the entire query, it is possible that\n                    // the symbol matches perfectly (e.g. searching for \"change log\"\n                    // can be a match on a markdown symbol \"change log\"). In that\n                    // case we want to skip the container query altogether.\n                    let skipContainerQuery = false;\n                    if (symbolQuery !== query) {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: undefined /* disable multi-query support */ }), filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore === 'number') {\n                            skipContainerQuery = true; // since we consumed the query, skip any container matching\n                        }\n                    }\n                    // Otherwise: score on the symbol query and match on the container later\n                    if (typeof symbolScore !== 'number') {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore !== 'number') {\n                            continue;\n                        }\n                    }\n                    // Score by container if specified\n                    if (!skipContainerQuery && containerQuery) {\n                        if (containerLabel && containerQuery.original.length > 0) {\n                            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                        }\n                        if (typeof containerScore !== 'number') {\n                            continue;\n                        }\n                        if (typeof symbolScore === 'number') {\n                            symbolScore += containerScore; // boost symbolScore by containerScore\n                        }\n                    }\n                }\n                const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n                filteredSymbolPicks.push({\n                    index,\n                    kind: symbol.kind,\n                    score: symbolScore,\n                    label: symbolLabelWithIcon,\n                    ariaLabel: symbolLabel,\n                    description: containerLabel,\n                    highlights: deprecated ? undefined : {\n                        label: symbolMatches,\n                        description: containerMatches\n                    },\n                    range: {\n                        selection: Range.collapseToStart(symbol.selectionRange),\n                        decoration: symbol.range\n                    },\n                    strikethrough: deprecated,\n                    buttons\n                });\n            }\n            // Sort by score\n            const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n                this.compareByKindAndScore(symbolA, symbolB) :\n                this.compareByScore(symbolA, symbolB));\n            // Add separator for types\n            // - @  only total number of symbols\n            // - @: grouped by symbol kind\n            let symbolPicks = [];\n            if (filterBySymbolKind) {\n                let lastSymbolKind = undefined;\n                let lastSeparator = undefined;\n                let lastSymbolKindCounter = 0;\n                function updateLastSeparatorLabel() {\n                    if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                        lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                    }\n                }\n                for (const symbolPick of sortedFilteredSymbolPicks) {\n                    // Found new kind\n                    if (lastSymbolKind !== symbolPick.kind) {\n                        // Update last separator with number of symbols we found for kind\n                        updateLastSeparatorLabel();\n                        lastSymbolKind = symbolPick.kind;\n                        lastSymbolKindCounter = 1;\n                        // Add new separator for new kind\n                        lastSeparator = { type: 'separator' };\n                        symbolPicks.push(lastSeparator);\n                    }\n                    // Existing kind, keep counting\n                    else {\n                        lastSymbolKindCounter++;\n                    }\n                    // Add to final result\n                    symbolPicks.push(symbolPick);\n                }\n                // Update last separator with number of symbols we found for kind\n                updateLastSeparatorLabel();\n            }\n            else if (sortedFilteredSymbolPicks.length > 0) {\n                symbolPicks = [\n                    { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                    ...sortedFilteredSymbolPicks\n                ];\n            }\n            return symbolPicks;\n        });\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    getDocumentSymbols(document, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = yield this._outlineModelService.getOrCreate(document, token);\n            return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n        });\n    }\n};\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;\nAbstractGotoSymbolQuickAccessProvider = __decorate([\n    __param(0, ILanguageFeaturesService),\n    __param(1, IOutlineModelService)\n], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n    [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n    [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n    [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n    [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n    [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n    [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n    [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n    [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n    [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n    [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n    [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}