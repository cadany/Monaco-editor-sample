{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { OffsetRange, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRange, LineRangeMapping, RangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n  constructor() {\n    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  }\n  computeDiff(originalLines, modifiedLines, options) {\n    const perfectHashes = new Map();\n    function getOrCreateHash(text) {\n      let hash = perfectHashes.get(text);\n      if (hash === undefined) {\n        hash = perfectHashes.size;\n        perfectHashes.set(text, hash);\n      }\n      return hash;\n    }\n    const srcDocLines = originalLines.map(l => getOrCreateHash(l.trim()));\n    const tgtDocLines = modifiedLines.map(l => getOrCreateHash(l.trim()));\n    const sequence1 = new LineSequence(srcDocLines, originalLines);\n    const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n    let lineAlignments = (() => {\n      if (sequence1.length + sequence2.length < 1500) {\n        // Use the improved algorithm for small files\n        return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);\n      }\n      return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n    })();\n    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n    const alignments = [];\n    const scanForWhitespaceChanges = equalLinesCount => {\n      for (let i = 0; i < equalLinesCount; i++) {\n        const seq1Offset = seq1LastStart + i;\n        const seq2Offset = seq2LastStart + i;\n        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n          // This is because of whitespace changes, diff these lines\n          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)));\n          for (const a of characterDiffs) {\n            alignments.push(a);\n          }\n        }\n      }\n    };\n    let seq1LastStart = 0;\n    let seq2LastStart = 0;\n    for (const diff of lineAlignments) {\n      assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n      const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n      scanForWhitespaceChanges(equalLinesCount);\n      seq1LastStart = diff.seq1Range.endExclusive;\n      seq2LastStart = diff.seq2Range.endExclusive;\n      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff);\n      for (const a of characterDiffs) {\n        alignments.push(a);\n      }\n    }\n    scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n    const changes = lineRangeMappingFromRangeMappings(alignments);\n    return {\n      quitEarly: false,\n      changes: changes\n    };\n  }\n  refineDiff(originalLines, modifiedLines, diff) {\n    const sourceSlice = new Slice(originalLines, diff.seq1Range);\n    const targetSlice = new Slice(modifiedLines, diff.seq2Range);\n    const originalDiffs = sourceSlice.length + targetSlice.length < 500 ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice) : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice);\n    let diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, originalDiffs);\n    diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);\n    const result = diffs.map(d => new RangeMapping(sourceSlice.translateRange(d.seq1Range).delta(diff.seq1Range.start), targetSlice.translateRange(d.seq2Range).delta(diff.seq2Range.start)));\n    return result;\n  }\n}\nexport function lineRangeMappingFromRangeMappings(alignments) {\n  const changes = [];\n  for (const g of group(alignments, (a1, a2) => a2.originalRange.startLineNumber - (a1.originalRange.endLineNumber - (a1.originalRange.endColumn > 1 ? 0 : 1)) <= 1 || a2.modifiedRange.startLineNumber - (a1.modifiedRange.endLineNumber - (a1.modifiedRange.endColumn > 1 ? 0 : 1)) <= 1)) {\n    const first = g[0];\n    const last = g[g.length - 1];\n    changes.push(new LineRangeMapping(new LineRange(first.originalRange.startLineNumber, last.originalRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), new LineRange(first.modifiedRange.startLineNumber, last.modifiedRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), g));\n  }\n  assertFn(() => {\n    return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n    // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n    m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n  });\n  return changes;\n}\nfunction* group(items, shouldBeGrouped) {\n  let currentGroup;\n  let last;\n  for (const item of items) {\n    if (last !== undefined && shouldBeGrouped(last, item)) {\n      currentGroup.push(item);\n    } else {\n      if (currentGroup) {\n        yield currentGroup;\n      }\n      currentGroup = [item];\n    }\n    last = item;\n  }\n  if (currentGroup) {\n    yield currentGroup;\n  }\n}\nexport class LineSequence {\n  constructor(trimmedHash, lines) {\n    this.trimmedHash = trimmedHash;\n    this.lines = lines;\n  }\n  getElement(offset) {\n    return this.trimmedHash[offset];\n  }\n  get length() {\n    return this.trimmedHash.length;\n  }\n  getBoundaryScore(length) {\n    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n    return 1000 - (indentationBefore + indentationAfter);\n  }\n}\nfunction getIndentation(str) {\n  let i = 0;\n  while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n    i++;\n  }\n  return i;\n}\nclass Slice {\n  constructor(lines, lineRange) {\n    this.lines = lines;\n    this.lineRange = lineRange;\n    let chars = 0;\n    this.firstCharOnLineOffsets = new Int32Array(lineRange.length);\n    for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n      const line = lines[i];\n      chars += line.length;\n      this.firstCharOnLineOffsets[i - lineRange.start] = chars + 1;\n      chars++;\n    }\n    this.elements = new Int32Array(chars);\n    let offset = 0;\n    for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n      const line = lines[i];\n      for (let i = 0; i < line.length; i++) {\n        this.elements[offset + i] = line.charCodeAt(i);\n      }\n      offset += line.length;\n      if (i < lines.length - 1) {\n        this.elements[offset] = '\\n'.charCodeAt(0);\n        offset += 1;\n      }\n    }\n  }\n  getElement(offset) {\n    return this.elements[offset];\n  }\n  get length() {\n    return this.elements.length;\n  }\n  getBoundaryScore(length) {\n    //   a   b   c   ,           d   e   f\n    // 11  0   0   12  15  6   13  0   0   11\n    const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n    const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n    if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n      // don't break between \\r and \\n\n      return 0;\n    }\n    let score = 0;\n    if (prevCategory !== nextCategory) {\n      score += 10;\n      if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n        score += 1;\n      }\n    }\n    score += getCategoryBoundaryScore(prevCategory);\n    score += getCategoryBoundaryScore(nextCategory);\n    return score;\n  }\n  translateOffset(offset) {\n    // find smallest i, so that lineBreakOffsets[i] > offset using binary search\n    let i = 0;\n    let j = this.firstCharOnLineOffsets.length;\n    while (i < j) {\n      const k = Math.floor((i + j) / 2);\n      if (this.firstCharOnLineOffsets[k] > offset) {\n        j = k;\n      } else {\n        i = k + 1;\n      }\n    }\n    const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOnLineOffsets[i - 1];\n    return new Position(i + 1, offset - offsetOfPrevLineBreak + 1);\n  }\n  translateRange(range) {\n    return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n  }\n}\nconst score = {\n  [0 /* CharBoundaryCategory.WordLower */]: 0,\n  [1 /* CharBoundaryCategory.WordUpper */]: 0,\n  [2 /* CharBoundaryCategory.WordNumber */]: 0,\n  [3 /* CharBoundaryCategory.End */]: 10,\n  [4 /* CharBoundaryCategory.Other */]: 2,\n  [5 /* CharBoundaryCategory.Space */]: 3,\n  [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n  [7 /* CharBoundaryCategory.LineBreakLF */]: 10\n};\nfunction getCategoryBoundaryScore(category) {\n  return score[category];\n}\nfunction getCategory(charCode) {\n  if (charCode === 10 /* CharCode.LineFeed */) {\n    return 7 /* CharBoundaryCategory.LineBreakLF */;\n  } else if (charCode === 13 /* CharCode.CarriageReturn */) {\n    return 6 /* CharBoundaryCategory.LineBreakCR */;\n  } else if (isSpace(charCode)) {\n    return 5 /* CharBoundaryCategory.Space */;\n  } else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n    return 0 /* CharBoundaryCategory.WordLower */;\n  } else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n    return 1 /* CharBoundaryCategory.WordUpper */;\n  } else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n    return 2 /* CharBoundaryCategory.WordNumber */;\n  } else if (charCode === -1) {\n    return 3 /* CharBoundaryCategory.End */;\n  } else {\n    return 4 /* CharBoundaryCategory.Other */;\n  }\n}\n\nfunction isSpace(charCode) {\n  return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}","map":{"version":3,"names":["assertFn","checkAdjacentItems","Position","Range","OffsetRange","SequenceDiff","DynamicProgrammingDiffing","optimizeSequenceDiffs","smoothenSequenceDiffs","MyersDiffAlgorithm","LineRange","LineRangeMapping","RangeMapping","StandardLinesDiffComputer","constructor","dynamicProgrammingDiffing","myersDiffingAlgorithm","computeDiff","originalLines","modifiedLines","options","perfectHashes","Map","getOrCreateHash","text","hash","get","undefined","size","set","srcDocLines","map","l","trim","tgtDocLines","sequence1","LineSequence","sequence2","lineAlignments","length","compute","offset1","offset2","Math","log","alignments","scanForWhitespaceChanges","equalLinesCount","i","seq1Offset","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","a","push","diff","seq1Range","start","seq2Range","endExclusive","changes","lineRangeMappingFromRangeMappings","quitEarly","sourceSlice","Slice","targetSlice","originalDiffs","diffs","result","d","translateRange","delta","g","group","a1","a2","originalRange","startLineNumber","endLineNumber","endColumn","modifiedRange","first","last","m1","m2","endLineNumberExclusive","items","shouldBeGrouped","currentGroup","item","trimmedHash","lines","getElement","offset","getBoundaryScore","indentationBefore","getIndentation","indentationAfter","str","charCodeAt","lineRange","chars","firstCharOnLineOffsets","Int32Array","line","elements","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","translateOffset","j","k","floor","offsetOfPrevLineBreak","range","fromPositions","category","charCode","isSpace"],"sources":["/Users/cadany/WebstormProjects/monaco/node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { OffsetRange, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRange, LineRangeMapping, RangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        let lineAlignments = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)));\n                    for (const a of characterDiffs) {\n                        alignments.push(a);\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff);\n            for (const a of characterDiffs) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments);\n        return {\n            quitEarly: false,\n            changes: changes,\n        };\n    }\n    refineDiff(originalLines, modifiedLines, diff) {\n        const sourceSlice = new Slice(originalLines, diff.seq1Range);\n        const targetSlice = new Slice(modifiedLines, diff.seq2Range);\n        const originalDiffs = sourceSlice.length + targetSlice.length < 500\n            ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice)\n            : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice);\n        let diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, originalDiffs);\n        diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);\n        const result = diffs.map((d) => new RangeMapping(sourceSlice.translateRange(d.seq1Range).delta(diff.seq1Range.start), targetSlice.translateRange(d.seq2Range).delta(diff.seq2Range.start)));\n        return result;\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments) {\n    const changes = [];\n    for (const g of group(alignments, (a1, a2) => (a2.originalRange.startLineNumber - (a1.originalRange.endLineNumber - (a1.originalRange.endColumn > 1 ? 0 : 1)) <= 1)\n        || (a2.modifiedRange.startLineNumber - (a1.modifiedRange.endLineNumber - (a1.modifiedRange.endColumn > 1 ? 0 : 1)) <= 1))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(new LineRange(first.originalRange.startLineNumber, last.originalRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), new LineRange(first.modifiedRange.startLineNumber, last.modifiedRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), g));\n    }\n    assertFn(() => {\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nclass Slice {\n    constructor(lines, lineRange) {\n        this.lines = lines;\n        this.lineRange = lineRange;\n        let chars = 0;\n        this.firstCharOnLineOffsets = new Int32Array(lineRange.length);\n        for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n            const line = lines[i];\n            chars += line.length;\n            this.firstCharOnLineOffsets[i - lineRange.start] = chars + 1;\n            chars++;\n        }\n        this.elements = new Int32Array(chars);\n        let offset = 0;\n        for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n            const line = lines[i];\n            for (let i = 0; i < line.length; i++) {\n                this.elements[offset + i] = line.charCodeAt(i);\n            }\n            offset += line.length;\n            if (i < lines.length - 1) {\n                this.elements[offset] = '\\n'.charCodeAt(0);\n                offset += 1;\n            }\n        }\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] > offset using binary search\n        let i = 0;\n        let j = this.firstCharOnLineOffsets.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOnLineOffsets[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOnLineOffsets[i - 1];\n        return new Position(i + 1, offset - offsetOfPrevLineBreak + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}