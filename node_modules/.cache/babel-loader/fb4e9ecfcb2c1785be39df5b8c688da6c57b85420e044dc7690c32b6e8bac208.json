{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { OutlineModel, OutlineElement, OutlineGroup } from '../../documentSymbols/browser/outlineModel.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { binarySearch } from '../../../../base/common/arrays.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { FoldingController } from '../../folding/browser/folding.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nexport class StickyRange {\n  constructor(startLineNumber, endLineNumber) {\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n}\nexport class StickyLineCandidate {\n  constructor(startLineNumber, endLineNumber, nestingDepth) {\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n    this.nestingDepth = nestingDepth;\n  }\n}\nlet StickyLineCandidateProvider = class StickyLineCandidateProvider extends Disposable {\n  constructor(editor, languageFeaturesService) {\n    super();\n    this._onDidChangeStickyScroll = this._store.add(new Emitter());\n    this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event;\n    this._sessionStore = new DisposableStore();\n    this._editor = editor;\n    this._languageFeaturesService = languageFeaturesService;\n    this._updateSoon = this._register(new RunOnceScheduler(() => this.update(), 50));\n    this._register(this._editor.onDidChangeConfiguration(e => {\n      if (e.hasChanged(109 /* EditorOption.stickyScroll */)) {\n        this.readConfiguration();\n      }\n    }));\n    this.readConfiguration();\n  }\n  dispose() {\n    super.dispose();\n    this._sessionStore.dispose();\n  }\n  readConfiguration() {\n    const options = this._editor.getOption(109 /* EditorOption.stickyScroll */);\n    if (options.enabled === false) {\n      this._sessionStore.clear();\n      return;\n    } else {\n      this._sessionStore.add(this._editor.onDidChangeModel(() => {\n        this.update();\n      }));\n      this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update()));\n      this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule()));\n      this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n        this.update();\n      }));\n      this.update();\n    }\n  }\n  getVersionId() {\n    var _a;\n    return (_a = this._model) === null || _a === void 0 ? void 0 : _a.version;\n  }\n  update() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = this._cts) === null || _a === void 0 ? void 0 : _a.dispose(true);\n      this._cts = new CancellationTokenSource();\n      yield this.updateOutlineModel(this._cts.token);\n      this._onDidChangeStickyScroll.fire();\n    });\n  }\n  updateOutlineModel(token) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._editor.hasModel()) {\n        return;\n      }\n      const model = this._editor.getModel();\n      const modelVersionId = model.getVersionId();\n      const isDifferentModel = this._model ? !isEqual(this._model.uri, model.uri) : false;\n      // clear sticky scroll to not show stale data for too long\n      const resetHandle = isDifferentModel ? setTimeout(() => {\n        if (!token.isCancellationRequested) {\n          this._model = new StickyOutlineModel(model.uri, model.getVersionId(), undefined, undefined);\n          this._onDidChangeStickyScroll.fire();\n        }\n      }, 75) : undefined;\n      // get elements from outline or folding model\n      const outlineModel = yield OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, model, token);\n      if (token.isCancellationRequested) {\n        return;\n      }\n      if (outlineModel.children.size !== 0) {\n        const {\n          stickyOutlineElement,\n          providerID\n        } = StickyOutlineElement.fromOutlineModel(outlineModel, (_a = this._model) === null || _a === void 0 ? void 0 : _a.outlineProviderId);\n        this._model = new StickyOutlineModel(model.uri, modelVersionId, stickyOutlineElement, providerID);\n      } else {\n        const foldingController = FoldingController.get(this._editor);\n        const foldingModel = yield foldingController === null || foldingController === void 0 ? void 0 : foldingController.getFoldingModel();\n        if (token.isCancellationRequested) {\n          return;\n        }\n        if (foldingModel && foldingModel.regions.length !== 0) {\n          const foldingElement = StickyOutlineElement.fromFoldingModel(foldingModel);\n          this._model = new StickyOutlineModel(model.uri, modelVersionId, foldingElement, undefined);\n        } else {\n          this._model = undefined;\n        }\n      }\n      clearTimeout(resetHandle);\n    });\n  }\n  updateIndex(index) {\n    if (index === -1) {\n      index = 0;\n    } else if (index < 0) {\n      index = -index - 2;\n    }\n    return index;\n  }\n  getCandidateStickyLinesIntersectingFromOutline(range, outlineModel, result, depth, lastStartLineNumber) {\n    if (outlineModel.children.length === 0) {\n      return;\n    }\n    let lastLine = lastStartLineNumber;\n    const childrenStartLines = [];\n    for (let i = 0; i < outlineModel.children.length; i++) {\n      const child = outlineModel.children[i];\n      if (child.range) {\n        childrenStartLines.push(child.range.startLineNumber);\n      }\n    }\n    const lowerBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber, (a, b) => {\n      return a - b;\n    }));\n    const upperBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber + depth, (a, b) => {\n      return a - b;\n    }));\n    for (let i = lowerBound; i <= upperBound; i++) {\n      const child = outlineModel.children[i];\n      if (!child) {\n        return;\n      }\n      if (child.range) {\n        const childStartLine = child.range.startLineNumber;\n        const childEndLine = child.range.endLineNumber;\n        if (range.startLineNumber <= childEndLine + 1 && childStartLine - 1 <= range.endLineNumber && childStartLine !== lastLine) {\n          lastLine = childStartLine;\n          result.push(new StickyLineCandidate(childStartLine, childEndLine - 1, depth + 1));\n          this.getCandidateStickyLinesIntersectingFromOutline(range, child, result, depth + 1, childStartLine);\n        }\n      } else {\n        this.getCandidateStickyLinesIntersectingFromOutline(range, child, result, depth, lastStartLineNumber);\n      }\n    }\n  }\n  getCandidateStickyLinesIntersecting(range) {\n    var _a, _b;\n    if (!((_a = this._model) === null || _a === void 0 ? void 0 : _a.element)) {\n      return [];\n    }\n    let stickyLineCandidates = [];\n    this.getCandidateStickyLinesIntersectingFromOutline(range, this._model.element, stickyLineCandidates, 0, -1);\n    const hiddenRanges = (_b = this._editor._getViewModel()) === null || _b === void 0 ? void 0 : _b.getHiddenAreas();\n    if (hiddenRanges) {\n      for (const hiddenRange of hiddenRanges) {\n        stickyLineCandidates = stickyLineCandidates.filter(stickyLine => !(stickyLine.startLineNumber >= hiddenRange.startLineNumber && stickyLine.endLineNumber <= hiddenRange.endLineNumber + 1));\n      }\n    }\n    return stickyLineCandidates;\n  }\n};\nStickyLineCandidateProvider = __decorate([__param(1, ILanguageFeaturesService)], StickyLineCandidateProvider);\nexport { StickyLineCandidateProvider };\nclass StickyOutlineElement {\n  static comparator(range1, range2) {\n    if (range1.startLineNumber !== range2.startLineNumber) {\n      return range1.startLineNumber - range2.startLineNumber;\n    } else {\n      return range2.endLineNumber - range1.endLineNumber;\n    }\n  }\n  static fromOutlineElement(outlineElement, previousStartLine) {\n    const children = [];\n    for (const child of outlineElement.children.values()) {\n      if (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {\n        if (child.symbol.selectionRange.startLineNumber !== previousStartLine) {\n          children.push(StickyOutlineElement.fromOutlineElement(child, child.symbol.selectionRange.startLineNumber));\n        } else {\n          for (const subchild of child.children.values()) {\n            children.push(StickyOutlineElement.fromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));\n          }\n        }\n      }\n    }\n    children.sort((child1, child2) => this.comparator(child1.range, child2.range));\n    const range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);\n    return new StickyOutlineElement(range, children, undefined);\n  }\n  static fromOutlineModel(outlineModel, preferredProvider) {\n    let outlineElements;\n    // When several possible outline providers\n    if (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {\n      const provider = Iterable.find(outlineModel.children.values(), outlineGroupOfModel => outlineGroupOfModel.id === preferredProvider);\n      if (provider) {\n        outlineElements = provider.children;\n      } else {\n        let tempID = '';\n        let maxTotalSumOfRanges = -1;\n        let optimalOutlineGroup = undefined;\n        for (const [_key, outlineGroup] of outlineModel.children.entries()) {\n          const totalSumRanges = StickyOutlineElement.findSumOfRangesOfGroup(outlineGroup);\n          if (totalSumRanges > maxTotalSumOfRanges) {\n            optimalOutlineGroup = outlineGroup;\n            maxTotalSumOfRanges = totalSumRanges;\n            tempID = outlineGroup.id;\n          }\n        }\n        preferredProvider = tempID;\n        outlineElements = optimalOutlineGroup.children;\n      }\n    } else {\n      outlineElements = outlineModel.children;\n    }\n    const stickyChildren = [];\n    const outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {\n      const range1 = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);\n      const range2 = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);\n      return this.comparator(range1, range2);\n    });\n    for (const outlineElement of outlineElementsArray) {\n      stickyChildren.push(StickyOutlineElement.fromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));\n    }\n    const stickyOutlineElement = new StickyOutlineElement(undefined, stickyChildren, undefined);\n    return {\n      stickyOutlineElement: stickyOutlineElement,\n      providerID: preferredProvider\n    };\n  }\n  static findSumOfRangesOfGroup(outline) {\n    let res = 0;\n    for (const child of outline.children.values()) {\n      res += this.findSumOfRangesOfGroup(child);\n    }\n    if (outline instanceof OutlineElement) {\n      return res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;\n    } else {\n      return res;\n    }\n  }\n  static fromFoldingModel(foldingModel) {\n    const regions = foldingModel.regions;\n    const length = regions.length;\n    let range;\n    const stackOfParents = [];\n    const stickyOutlineElement = new StickyOutlineElement(undefined, [], undefined);\n    let parentStickyOutlineElement = stickyOutlineElement;\n    for (let i = 0; i < length; i++) {\n      range = new StickyRange(regions.getStartLineNumber(i), regions.getEndLineNumber(i) + 1);\n      while (stackOfParents.length !== 0 && (range.startLineNumber < stackOfParents[stackOfParents.length - 1].startLineNumber || range.endLineNumber > stackOfParents[stackOfParents.length - 1].endLineNumber)) {\n        stackOfParents.pop();\n        if (parentStickyOutlineElement.parent !== undefined) {\n          parentStickyOutlineElement = parentStickyOutlineElement.parent;\n        }\n      }\n      const child = new StickyOutlineElement(range, [], parentStickyOutlineElement);\n      parentStickyOutlineElement.children.push(child);\n      parentStickyOutlineElement = child;\n      stackOfParents.push(range);\n    }\n    return stickyOutlineElement;\n  }\n  constructor(\n  /**\n   * Range of line numbers spanned by the current scope\n   */\n  range,\n  /**\n   * Must be sorted by start line number\n  */\n  children,\n  /**\n   * Parent sticky outline element\n   */\n  parent) {\n    this.range = range;\n    this.children = children;\n    this.parent = parent;\n  }\n}\nclass StickyOutlineModel {\n  constructor(uri, version, element, outlineProviderId) {\n    this.uri = uri;\n    this.version = version;\n    this.element = element;\n    this.outlineProviderId = outlineProviderId;\n  }\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Disposable","DisposableStore","ILanguageFeaturesService","OutlineModel","OutlineElement","OutlineGroup","CancellationTokenSource","RunOnceScheduler","Emitter","binarySearch","Iterable","FoldingController","isEqual","StickyRange","constructor","startLineNumber","endLineNumber","StickyLineCandidate","nestingDepth","StickyLineCandidateProvider","editor","languageFeaturesService","_onDidChangeStickyScroll","_store","add","onDidChangeStickyScroll","event","_sessionStore","_editor","_languageFeaturesService","_updateSoon","_register","update","onDidChangeConfiguration","hasChanged","readConfiguration","dispose","options","getOption","enabled","clear","onDidChangeModel","onDidChangeHiddenAreas","onDidChangeModelContent","schedule","documentSymbolProvider","onDidChange","getVersionId","_a","_model","version","_cts","updateOutlineModel","token","fire","hasModel","model","getModel","modelVersionId","isDifferentModel","uri","resetHandle","setTimeout","isCancellationRequested","StickyOutlineModel","undefined","outlineModel","create","children","size","stickyOutlineElement","providerID","StickyOutlineElement","fromOutlineModel","outlineProviderId","foldingController","get","foldingModel","getFoldingModel","regions","foldingElement","fromFoldingModel","clearTimeout","updateIndex","index","getCandidateStickyLinesIntersectingFromOutline","range","depth","lastStartLineNumber","lastLine","childrenStartLines","child","push","lowerBound","a","b","upperBound","childStartLine","childEndLine","getCandidateStickyLinesIntersecting","_b","element","stickyLineCandidates","hiddenRanges","_getViewModel","getHiddenAreas","hiddenRange","filter","stickyLine","comparator","range1","range2","fromOutlineElement","outlineElement","previousStartLine","values","symbol","selectionRange","subchild","sort","child1","child2","preferredProvider","outlineElements","first","provider","find","outlineGroupOfModel","id","tempID","maxTotalSumOfRanges","optimalOutlineGroup","_key","outlineGroup","entries","totalSumRanges","findSumOfRangesOfGroup","stickyChildren","outlineElementsArray","Array","from","element1","element2","outline","res","stackOfParents","parentStickyOutlineElement","getStartLineNumber","getEndLineNumber","pop","parent"],"sources":["/Users/cadany/WebstormProjects/monaco/node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { OutlineModel, OutlineElement, OutlineGroup } from '../../documentSymbols/browser/outlineModel.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { binarySearch } from '../../../../base/common/arrays.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { FoldingController } from '../../folding/browser/folding.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nexport class StickyRange {\n    constructor(startLineNumber, endLineNumber) {\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n    }\n}\nexport class StickyLineCandidate {\n    constructor(startLineNumber, endLineNumber, nestingDepth) {\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.nestingDepth = nestingDepth;\n    }\n}\nlet StickyLineCandidateProvider = class StickyLineCandidateProvider extends Disposable {\n    constructor(editor, languageFeaturesService) {\n        super();\n        this._onDidChangeStickyScroll = this._store.add(new Emitter());\n        this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event;\n        this._sessionStore = new DisposableStore();\n        this._editor = editor;\n        this._languageFeaturesService = languageFeaturesService;\n        this._updateSoon = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._register(this._editor.onDidChangeConfiguration(e => {\n            if (e.hasChanged(109 /* EditorOption.stickyScroll */)) {\n                this.readConfiguration();\n            }\n        }));\n        this.readConfiguration();\n    }\n    dispose() {\n        super.dispose();\n        this._sessionStore.dispose();\n    }\n    readConfiguration() {\n        const options = this._editor.getOption(109 /* EditorOption.stickyScroll */);\n        if (options.enabled === false) {\n            this._sessionStore.clear();\n            return;\n        }\n        else {\n            this._sessionStore.add(this._editor.onDidChangeModel(() => {\n                this.update();\n            }));\n            this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update()));\n            this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule()));\n            this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n                this.update();\n            }));\n            this.update();\n        }\n    }\n    getVersionId() {\n        var _a;\n        return (_a = this._model) === null || _a === void 0 ? void 0 : _a.version;\n    }\n    update() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this._cts) === null || _a === void 0 ? void 0 : _a.dispose(true);\n            this._cts = new CancellationTokenSource();\n            yield this.updateOutlineModel(this._cts.token);\n            this._onDidChangeStickyScroll.fire();\n        });\n    }\n    updateOutlineModel(token) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const model = this._editor.getModel();\n            const modelVersionId = model.getVersionId();\n            const isDifferentModel = this._model ? !isEqual(this._model.uri, model.uri) : false;\n            // clear sticky scroll to not show stale data for too long\n            const resetHandle = isDifferentModel ? setTimeout(() => {\n                if (!token.isCancellationRequested) {\n                    this._model = new StickyOutlineModel(model.uri, model.getVersionId(), undefined, undefined);\n                    this._onDidChangeStickyScroll.fire();\n                }\n            }, 75) : undefined;\n            // get elements from outline or folding model\n            const outlineModel = yield OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, model, token);\n            if (token.isCancellationRequested) {\n                return;\n            }\n            if (outlineModel.children.size !== 0) {\n                const { stickyOutlineElement, providerID } = StickyOutlineElement.fromOutlineModel(outlineModel, (_a = this._model) === null || _a === void 0 ? void 0 : _a.outlineProviderId);\n                this._model = new StickyOutlineModel(model.uri, modelVersionId, stickyOutlineElement, providerID);\n            }\n            else {\n                const foldingController = FoldingController.get(this._editor);\n                const foldingModel = yield (foldingController === null || foldingController === void 0 ? void 0 : foldingController.getFoldingModel());\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (foldingModel && foldingModel.regions.length !== 0) {\n                    const foldingElement = StickyOutlineElement.fromFoldingModel(foldingModel);\n                    this._model = new StickyOutlineModel(model.uri, modelVersionId, foldingElement, undefined);\n                }\n                else {\n                    this._model = undefined;\n                }\n            }\n            clearTimeout(resetHandle);\n        });\n    }\n    updateIndex(index) {\n        if (index === -1) {\n            index = 0;\n        }\n        else if (index < 0) {\n            index = -index - 2;\n        }\n        return index;\n    }\n    getCandidateStickyLinesIntersectingFromOutline(range, outlineModel, result, depth, lastStartLineNumber) {\n        if (outlineModel.children.length === 0) {\n            return;\n        }\n        let lastLine = lastStartLineNumber;\n        const childrenStartLines = [];\n        for (let i = 0; i < outlineModel.children.length; i++) {\n            const child = outlineModel.children[i];\n            if (child.range) {\n                childrenStartLines.push(child.range.startLineNumber);\n            }\n        }\n        const lowerBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber, (a, b) => { return a - b; }));\n        const upperBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber + depth, (a, b) => { return a - b; }));\n        for (let i = lowerBound; i <= upperBound; i++) {\n            const child = outlineModel.children[i];\n            if (!child) {\n                return;\n            }\n            if (child.range) {\n                const childStartLine = child.range.startLineNumber;\n                const childEndLine = child.range.endLineNumber;\n                if (range.startLineNumber <= childEndLine + 1 && childStartLine - 1 <= range.endLineNumber && childStartLine !== lastLine) {\n                    lastLine = childStartLine;\n                    result.push(new StickyLineCandidate(childStartLine, childEndLine - 1, depth + 1));\n                    this.getCandidateStickyLinesIntersectingFromOutline(range, child, result, depth + 1, childStartLine);\n                }\n            }\n            else {\n                this.getCandidateStickyLinesIntersectingFromOutline(range, child, result, depth, lastStartLineNumber);\n            }\n        }\n    }\n    getCandidateStickyLinesIntersecting(range) {\n        var _a, _b;\n        if (!((_a = this._model) === null || _a === void 0 ? void 0 : _a.element)) {\n            return [];\n        }\n        let stickyLineCandidates = [];\n        this.getCandidateStickyLinesIntersectingFromOutline(range, this._model.element, stickyLineCandidates, 0, -1);\n        const hiddenRanges = (_b = this._editor._getViewModel()) === null || _b === void 0 ? void 0 : _b.getHiddenAreas();\n        if (hiddenRanges) {\n            for (const hiddenRange of hiddenRanges) {\n                stickyLineCandidates = stickyLineCandidates.filter(stickyLine => !(stickyLine.startLineNumber >= hiddenRange.startLineNumber && stickyLine.endLineNumber <= hiddenRange.endLineNumber + 1));\n            }\n        }\n        return stickyLineCandidates;\n    }\n};\nStickyLineCandidateProvider = __decorate([\n    __param(1, ILanguageFeaturesService)\n], StickyLineCandidateProvider);\nexport { StickyLineCandidateProvider };\nclass StickyOutlineElement {\n    static comparator(range1, range2) {\n        if (range1.startLineNumber !== range2.startLineNumber) {\n            return range1.startLineNumber - range2.startLineNumber;\n        }\n        else {\n            return range2.endLineNumber - range1.endLineNumber;\n        }\n    }\n    static fromOutlineElement(outlineElement, previousStartLine) {\n        const children = [];\n        for (const child of outlineElement.children.values()) {\n            if (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {\n                if (child.symbol.selectionRange.startLineNumber !== previousStartLine) {\n                    children.push(StickyOutlineElement.fromOutlineElement(child, child.symbol.selectionRange.startLineNumber));\n                }\n                else {\n                    for (const subchild of child.children.values()) {\n                        children.push(StickyOutlineElement.fromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));\n                    }\n                }\n            }\n        }\n        children.sort((child1, child2) => this.comparator(child1.range, child2.range));\n        const range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);\n        return new StickyOutlineElement(range, children, undefined);\n    }\n    static fromOutlineModel(outlineModel, preferredProvider) {\n        let outlineElements;\n        // When several possible outline providers\n        if (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {\n            const provider = Iterable.find(outlineModel.children.values(), outlineGroupOfModel => outlineGroupOfModel.id === preferredProvider);\n            if (provider) {\n                outlineElements = provider.children;\n            }\n            else {\n                let tempID = '';\n                let maxTotalSumOfRanges = -1;\n                let optimalOutlineGroup = undefined;\n                for (const [_key, outlineGroup] of outlineModel.children.entries()) {\n                    const totalSumRanges = StickyOutlineElement.findSumOfRangesOfGroup(outlineGroup);\n                    if (totalSumRanges > maxTotalSumOfRanges) {\n                        optimalOutlineGroup = outlineGroup;\n                        maxTotalSumOfRanges = totalSumRanges;\n                        tempID = outlineGroup.id;\n                    }\n                }\n                preferredProvider = tempID;\n                outlineElements = optimalOutlineGroup.children;\n            }\n        }\n        else {\n            outlineElements = outlineModel.children;\n        }\n        const stickyChildren = [];\n        const outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {\n            const range1 = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);\n            const range2 = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);\n            return this.comparator(range1, range2);\n        });\n        for (const outlineElement of outlineElementsArray) {\n            stickyChildren.push(StickyOutlineElement.fromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));\n        }\n        const stickyOutlineElement = new StickyOutlineElement(undefined, stickyChildren, undefined);\n        return {\n            stickyOutlineElement: stickyOutlineElement,\n            providerID: preferredProvider\n        };\n    }\n    static findSumOfRangesOfGroup(outline) {\n        let res = 0;\n        for (const child of outline.children.values()) {\n            res += this.findSumOfRangesOfGroup(child);\n        }\n        if (outline instanceof OutlineElement) {\n            return res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;\n        }\n        else {\n            return res;\n        }\n    }\n    static fromFoldingModel(foldingModel) {\n        const regions = foldingModel.regions;\n        const length = regions.length;\n        let range;\n        const stackOfParents = [];\n        const stickyOutlineElement = new StickyOutlineElement(undefined, [], undefined);\n        let parentStickyOutlineElement = stickyOutlineElement;\n        for (let i = 0; i < length; i++) {\n            range = new StickyRange(regions.getStartLineNumber(i), regions.getEndLineNumber(i) + 1);\n            while (stackOfParents.length !== 0 && (range.startLineNumber < stackOfParents[stackOfParents.length - 1].startLineNumber || range.endLineNumber > stackOfParents[stackOfParents.length - 1].endLineNumber)) {\n                stackOfParents.pop();\n                if (parentStickyOutlineElement.parent !== undefined) {\n                    parentStickyOutlineElement = parentStickyOutlineElement.parent;\n                }\n            }\n            const child = new StickyOutlineElement(range, [], parentStickyOutlineElement);\n            parentStickyOutlineElement.children.push(child);\n            parentStickyOutlineElement = child;\n            stackOfParents.push(range);\n        }\n        return stickyOutlineElement;\n    }\n    constructor(\n    /**\n     * Range of line numbers spanned by the current scope\n     */\n    range, \n    /**\n     * Must be sorted by start line number\n    */\n    children, \n    /**\n     * Parent sticky outline element\n     */\n    parent) {\n        this.range = range;\n        this.children = children;\n        this.parent = parent;\n    }\n}\nclass StickyOutlineModel {\n    constructor(uri, version, element, outlineProviderId) {\n        this.uri = uri;\n        this.version = version;\n        this.element = element;\n        this.outlineProviderId = outlineProviderId;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}