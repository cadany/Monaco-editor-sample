{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange, SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  let result = sequenceDiffs;\n  result = joinSequenceDiffs(sequence1, sequence2, result);\n  result = shiftSequenceDiffs(sequence1, sequence2, result);\n  return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  const result = [];\n  for (const s of sequenceDiffs) {\n    const last = result[result.length - 1];\n    if (!last) {\n      result.push(s);\n      continue;\n    }\n    if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n    } else {\n      result.push(s);\n    }\n  }\n  return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  const result = [];\n  if (sequenceDiffs.length > 0) {\n    result.push(sequenceDiffs[0]);\n  }\n  for (let i = 1; i < sequenceDiffs.length; i++) {\n    const lastResult = result[result.length - 1];\n    const cur = sequenceDiffs[i];\n    if (cur.seq1Range.isEmpty) {\n      let all = true;\n      const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;\n      for (let i = 1; i <= length; i++) {\n        if (sequence2.getElement(cur.seq2Range.start - i) !== sequence2.getElement(cur.seq2Range.endExclusive - i)) {\n          all = false;\n          break;\n        }\n      }\n      if (all) {\n        // Merge previous and current diff\n        result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n        continue;\n      }\n    }\n    result.push(cur);\n  }\n  return result;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n    return sequenceDiffs;\n  }\n  for (let i = 0; i < sequenceDiffs.length; i++) {\n    const diff = sequenceDiffs[i];\n    if (diff.seq1Range.isEmpty) {\n      const seq2PrevEndExclusive = i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1;\n      const seq2NextStart = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length;\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);\n    } else if (diff.seq2Range.isEmpty) {\n      const seq1PrevEndExclusive = i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1;\n      const seq1NextStart = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length;\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();\n    }\n  }\n  return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {\n  const maxShiftLimit = 20; // To prevent performance issues\n  // don't touch previous or next!\n  let deltaBefore = 1;\n  while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive && sequence2.getElement(diff.seq2Range.start - deltaBefore) === sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n    deltaBefore++;\n  }\n  deltaBefore--;\n  let deltaAfter = 0;\n  while (diff.seq2Range.start + deltaAfter < seq2NextStart && sequence2.getElement(diff.seq2Range.start + deltaAfter) === sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n    deltaAfter++;\n  }\n  if (deltaBefore === 0 && deltaAfter === 0) {\n    return diff;\n  }\n  // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n  // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n  let bestDelta = 0;\n  let bestScore = -1;\n  // find best scored delta\n  for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n    const seq2OffsetStart = diff.seq2Range.start + delta;\n    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n    const seq1Offset = diff.seq1Range.start + delta;\n    const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n    if (score > bestScore) {\n      bestScore = score;\n      bestDelta = delta;\n    }\n  }\n  if (bestDelta !== 0) {\n    return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));\n  }\n  return diff;\n}","map":{"version":3,"names":["OffsetRange","SequenceDiff","optimizeSequenceDiffs","sequence1","sequence2","sequenceDiffs","result","joinSequenceDiffs","shiftSequenceDiffs","smoothenSequenceDiffs","s","last","length","push","seq1Range","start","endExclusive","seq2Range","join","i","lastResult","cur","isEmpty","all","getElement","getBoundaryScore","diff","seq2PrevEndExclusive","seq2NextStart","shiftDiffToBetterPosition","seq1PrevEndExclusive","seq1NextStart","reverse","maxShiftLimit","deltaBefore","deltaAfter","bestDelta","bestScore","delta","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score"],"sources":["/Users/cadany/WebstormProjects/monaco/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange, SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    if (sequenceDiffs.length > 0) {\n        result.push(sequenceDiffs[0]);\n    }\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const lastResult = result[result.length - 1];\n        const cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty) {\n            let all = true;\n            const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;\n            for (let i = 1; i <= length; i++) {\n                if (sequence2.getElement(cur.seq2Range.start - i) !== sequence2.getElement(cur.seq2Range.endExclusive - i)) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n        }\n        result.push(cur);\n    }\n    return result;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const diff = sequenceDiffs[i];\n        if (diff.seq1Range.isEmpty) {\n            const seq2PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1);\n            const seq2NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            const seq1PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1);\n            const seq1NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {\n    const maxShiftLimit = 20; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq2Range.start + deltaAfter < seq2NextStart &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    if (bestDelta !== 0) {\n        return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));\n    }\n    return diff;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}